@node Getting started
@chapter Getting started

@menu
* Installing and configuring @cuis{}::
* Writing your first scripts::
* Introduction to the system classes::
@end menu
                                   
@node Installing and configuring @cuis{}
@section Installing and configuring @cuis{}
@cuis{} is an environment and a programming language executed on a
virtual computer. It is based on two major components:
the Smalltalk @dfn{virtual machine} conceptualizing this virtual
computer and an @dfn{image} representing the state of this computer.

The virtual machine is an executable program running on a dedicated
host (GNU/Linux, Mac OS X, Windows, etc.). It is called the @dfn{Open
Smalltalk Virtual Machine}, or Squeak @vm{} in short. There are
different flavors of @vm{}, one for each combination of Operating
System and CPU architecture. Therefore, one @vm{} compiled
for Windows in Intel architecture will not work on Linux in
ARM architecture. You need the specific @vm{} compiled for
the combination of Operating System and CPU architecture
your computer is based on.

The image is a regular file feeding the @vm{} with all the objects
 defining the state of the virtual computer. These objects are
 classes, methods, instances of those classes as numbers, strings,
 windows, debuggers whatever existed when the state of the virtual
 computer was saved. An image file saved on a given Operating System
 and CPU architecture run identically on another system as
 long as the same @vm{} version is used.

What makes @cuis{} special is the living entities in the image: its
classes population and arrangement, how they inherit from each
other. The @cuis{} moto is to be a tiny, coherent and human
understandable Smalltalk environment; its class count is typically
less than 600.

To get you started easily, we provide three
archives@footnote{@url{http://github.com/Cuis-Smalltalk/BookResources}}
for GNU/Linux, Mac OS X and Windows on Intel architecture. These
archives come with the dedicated @vm{} and the image of @cuis{}
@value{cuisVersion}. Into this image we pre-installed a few packages
to make your life easier when you experience the examples and
exercises of the book. At the reading time of this book, @cuis{} has
likely evolved with a more recent version, nevertheless your learning
is transferable to more recent version of @cuis{}.

To get @cuis{} running on your computer, follow the instructions in
the @file{README} file accompanying the archive. Once you get @cuis{}
running, read the information displayed on the windows. When you are
done, close these windows, next you will adjust @cuis{} to your
preferences.

@subsection Editing your preferences
Once you read the instructions on the default windows, the second
things you want to do is to adjust its visual properties to fit your
preferences and needs. To do so, access the World menu
...@clicksequence{Background click @click{} Preferences...} then
select the pin on the top right of the menu to make it permanent. Here
you have the most important options: the choice for the @strong{font
size}, the @strong{themes} whenever your prefer light or dark
colouring. There are other preferences you can explore by
yourself. Once you are done, access again the World menu
...@clicksequence{Background click @click{} Save}... to make your
preferences permanent. In this book, we keep the default @cuis{}
theme, we suggest you to do the same so your environment reflects the
book screenshots.

@figure{Set Preferences,B-01-Preferences,12}

@subsection Fun with window placement
@cindex tools, workspace
The first tool to discover is the @dfn{Workspace} tool. It is a kind
of text editor to key in Smalltalk code you can execute
immediately. Do a ...@clicksequence{Background click @click{}
Open... @click{} Workspace}...

Now we ask @cuis{} to make the windows placement: click the blue icon
(top left) to access the window option and experiment with the white
area to place the Workspace window at the half left of the @cuis{}
environment.

@figure{Window options,B-01-img1a,7}

The @option{resize...} option even offers more freedom to place the
window. Resolve the following exercise:

@exercise{Middle placement,exePlacement, @emph{Use the
@option{resize...} option to place the Workspace centered on @cuis{}
environment.}}

@node Writing your first scripts
@section Writing your first scripts
In this section we present a few scripts so you will get a taste and
feeling about Smalltalk code. The examples are associated with small
exercises to experiment with and accompanied with solutions in the
annex. We intentionally keep the details of the syntax out of this
section.

Smalltalk script are usually written in a Workspace. The usual
@emph{Hello world!} program is written as:

@smalltalkExampleCaption{The traditional 'Hello World!' program,hello,
Transcript show: 'Hello World'}

@cindex tools, transcript
To execute this code, select it with the mouse and
...@clicksequence{right mouse click @click{} Do it (d)}...  Nothing
happen! Indeed to see the output, you need a @dfn{Transcript} window,
it is a place where programmer send information for the user as we are
doing in our example. Do ...@clicksequence{Background click @click{}
Open... @click{} Transcript}... and execute again the code.

@figure{Transcript window with output,B-01-img2,3}

This code comes in three parts:

@itemize

@item the literal @smalltalk{'Hello World!'}  

@item the message @msg{show:} with its argument @smalltalk{'Hello World!'}

@item the class @class{Transcript} receiving the message @msg{show:} with its argument

@end itemize

The action of printing takes place in the class
@class{Transcript}. The code execution is invoked with keyboard
shortcuts @kbd{Ctrl-A} then @kbd{Ctrl-D} (@emph{@b{D}o it}).

@smalltalkExampleCaption{Multiple lines, hello2,
Transcript show: 'Hello World!'.
Transcript newLine.
Transcript show: 'I am Cuising'}

In this three lines script, observe how the line are separated by a
dot ``.''. It is really a line separator not needed in the third line
nor in a one line script. The message @msg{newLine} has no argument.

@cindex cascade of messages
In the @ref{hello2} example, the message @msg{show:} and @msg{newLine}
are sent to the same @class{Transcript} class. In such circumstance,
we can use the cascade technique to avoid this repetition. The
receiver @class{Transcript} is written once and the sent messages are
separated by semicolon:

@smalltalkExampleCaption{Cascade of message, helloCascade,
Transcript
   show: 'Hello World!';
   newLine;
   show: 'I am Cuising'}

Observe the text layout to ease code understanding. It is possible to
write the cascade of messages in one line, but it reduces the
readability of the code:

@smalltalkExample{Transcript show: 'Hello World!'; newLine; show: 'I am Cuising'}

The @class{Transcript} class is most of the time used to output useful
information when developing an application. As an alternative to the
@kbd{Ctrl-d} shortcut, @kbd{Ctrl-p} (@emph{@b{P}rint it}) executes the
script and prints in the Workspace the result of the last line of the
script.

@c==start here

@subsection Fun with numbers
@cindex number, integer

In your Workspace, to compute a factorial execute the example bellow
with @kbd{Ctrl-a} then @kbd{Ctrl-p}:
@smalltalkExample{100 factorial
@result{}  9332621544394415268169923885626670049071596826438162146859
29638952175999932299156089414639761565182862536979208272237582
51185210916864000000000000000000000000}

@cuis{} handles very large integer number without the need to use
special type or method. To convince yourelf try the example bellow:
@smalltalkExample{10000 factorial / 9999 factorial
@result{} 10000}

If you execute and print with @kbd{Ctrl-p} @smalltalk{10000
factorial}, you realize it takes far more time to print one factorial
than computing two factorials and a division. The result is an integer
as expected, not a decimal number answer as many computer languages
will return.

As we are discussing division, you may not get the result you think:
@smalltalkExample{15 / 4
@result{} 15/4}

It looks like @cuis{} is lazy because it does not respond the decimal
number @smalltalk{3.75} as we were expecting. In fact @cuis{} wants to
be as accurate as possible, and its answer is a rational fraction! After
all, fractions are just division we are too lazy -- because it
is troublesome -- to compute, @cuis{} does just that!

Try out this to understand what is happening underneath:
@smalltalkExample{(15 / 4) + (1 / 4)
@result{} 4}

Is it not wonderful? @cuis{} computes with rational numbers. We
started with division and addition operations on integer, and we got
an accurate result thanks to intermediate computation on rational
numbers.

@cuisNote{In the example, observe how the parenthesis are used
although in arithmetic calculation the division is operated first. With
@cuis{} you need to explicit the order of operation with
parenthesis. We will explain why in Part Two.}

@exercise{Inverse sum,inverseSum, @emph{Write the code to compute the
sum of the first four integer inverses.}}
@cindex number, root
@cindex number, @msg{sqrt}
@cindex number, @msg{squared}
All four arithmetic operations and mathematical functions are
compatible with the rational number representation:
@smalltalkExample {(15 / 14) * (21 / 5) @result{} 9 / 2
(15 / 14) / ( 5 / 21) @result{} 9 /2 
(3 / 4) squared @result{} 9 / 16
(25 / 4) sqrt @result{} 5 / 2}

@exercise{Sum of the squares,squaredSum,Write the code to compute the
sum of the squares of the inverse of the first four integers.}

@cindex number, decimal division
If @cuis{} divides integer as rational number, how to compute the
decimal division? One option is to write a number as a @dfn{Float}, it
is the decimal representation in programming language, the integer
part and fractional parts are separated by a dot ``.'':
@smalltalkExample{ 15.0 / 4 @result{}3.75
15 / 4.0 @result{} 3.75}

Another option is to convert an integer to a float with the
@msg{asFloat} message. It is very useful when the integer is in a
variable:

@smalltalkExample{15 asFloat / 4
@result{} 3.75}

@cindex number, integer division
Alternatively to the decimal division, you ask integer division with
the message @msg{//}:
@smalltalkExample{15 // 4
@result{} 3}

@cindex number, division reminder
The reminder of the Euclidean division is computed with the message
@msg{\\\\}:
@smalltalkExample{15 \\\\ 4
@result{} 3}


@cindex number, @msg{odd}
@cindex number, @msg{even}
@cindex number, @msg{isPrime}
@cindex number, @msg{isDivisibleBy:}
@cuis{} knows some arithmetic operations to test if an integer is an
odd, even or prime number. You just send the appropriate message to
the number:

@smalltalkExampleCaption{Testing on integer,integerBasicTest,
25 odd @result{} true
25 even @result{} false
25 isPrime @result{} false
23 isPrime @result{} true
91 isDivisibleBy: 7 @result{} true
117 isDivisibleBy: 7 @result{} false
117 isDivisibleBy: 9 @result{} true}

@cindex number, @msg{gcd:}
@cindex number, @msg{lcm:}
With specific @dfn{keyword messages} you compute the Least Common
Multiple and Greatest Common Divisor. A keyword message is composed of
one or several colon(s) ``:'' to insert argument(s):

@smalltalkExample{12 lcm: 15 @result{} 60
12 gcd: 15 @result{} 3}
Integer can be printed in different forms:

@cindex number, roman
@cindex number, as words
@cindex number, base
@smalltalkExample{2020 printStringRoman @result{} 'MMXX' 
2020 printStringWords  @result{} 'two thousand, twenty'
"Number as the Maya did"
2020 printStringBase: 20 @result{} '510'}


@subsubheading Hiatus with decimal numbers
@cindex number, decimal
We saw decimal numbers are written with a dot ``.'' to separate the
integer and the decimal parts: @smalltalk{1.5}, @smalltalk{1235.021}
or @smalltalk{0.5}. The number @smalltalk{0.00004} is more easily
written @smalltalk{4e-5}; it means 4 preceded by 5 zeros or 4 as the
fifth digit after the decimal dot.

@strong{Attention.} Computer represents decimal number
imprecisely. You need to be aware of that when doing computation and
equality comparison. Most system hides these errors because there are
very tiny errors. @cuis{} does not hide these inaccuracy.

@smalltalkExampleCaption{Computer dyscalculia!,FloatPrecision,
0.1 + 0.2 - 0.3
@result{} 5.551115123125783e-17}

In @ref{FloatPrecision}, the returned value should be zero but it is
not the case. The computer returns @smalltalk{5.55e-17}, or
@smalltalk{0.0000000000000000555}, it is very close to zero, but there
is an error.

@exercise{Miscellaneous calculation errors with decimal
number,exeFloatPrecision,@emph{Give 3 calculations showing errors compared
to the expected results.}}

When accuracy is absolutely mandatory use the Rational Numbers
representation of @cuis{}.

@cindex number, rational
@cindex number, fraction
A rational number is written with the division symbol between two
integers: do @kbd{Ctrl-p} on @smalltalk{5/2} @result{}
@smalltalk{5/2}. @cuis{} returns a rational fraction, it does not compute a
decimal.

@exercise{Toward the infinite,exeZeroDivide, @emph{What happen when
executing this code} @smalltalk{5/0}@emph{?}}

Let's come back to our computer dyscalculia with decimal numbers. When
using the rational numbers, the @ref{FloatPrecision} becomes:

@smalltalkExampleCaption{Right with fraction!,FractionPrecision,
(1/10) + (2/10) - (3/10)
@result{} 0}

This time we have the expected result. Underneath the computer only
does the calculations with integers.

@exercise{Fix the errors,exeFractionPrecision, @emph{Return to
@ref{exeFloatPrecision} and use rational writing to represent decimal
numbers. The errors are gone.}}

@cuis{} knows how to convert a decimal number as a fraction, by
sending the message @msg{asFraction}. We already acknowledged the
computer dyscalculia trouble with decimal number, this is why when
asking for a fraction representation we have this strange answer. The
internal computer represenation of @smalltalk{1.3} is not exactly as
it seems:

@smalltalkExample{(13/10) asFloat
@result{} 1.3}
@smalltalkExample{(13/10) asFloat asFraction
@result{} 5854679515581645/45035996273704}

@subsection Fun with text
@cindex string
A @dfn{String} is the way text is represented in a programming
language, it is a collection of characters. We already met string with
our first script, it is enclosed in single quotes:
@smalltalk{'hello world!'}. We capitalize it with the @msg{capitalized}:

@cindex string, capitalized
@smalltalkExample{'hello world!' capitalized
@result{} 'Hello world!' }

@exercise{Capitalize number as words,capWordNumber,@emph{Print 2020 as
words capitalized.}}

@cindex string, concatenate
Two strings are concatenated with the @msg{,} message
@smalltalkExample{'Hello', ' ', 'my beloved', ' ', 'friend'
@result{} 'Hello my beloved friend'}

@cindex string, character access
Access to a character in a string is done with the keyword message
@msg{at:} and its index position in the string:
@smalltalkExample{'Hello' at: 1 @result{} $H
'Hello' at: 5 @result{} $o}

Observe how a character is prefixed with the ``$'' symbol.

@strong{Caution.} The index position starts naturally from 1 to the
string length.

To change one character, use the companion two keywords message
@msg{at:put:}. The argument must be noted as a character:
@smalltalkExample{'Hello' at: 2 put: $a; yourself
@result{} 'Hallo'}

Observe the use of the cascade with the @msg{yourself} message. It is
sent to the instance string to get it returned.

@exercise{Hello to Belle,helloBelle, @emph{Replace each character of
the string 'Hello' to become 'Belle'}}

@cindex character, ascii
Character can be converted to integer and integer to character:
@smalltalkExample{$A asciiValue @result{} 65
(65 + 25) asCharacter @result{} $Z}

@cindex string, shuffled
@cindex collection, shuffled
Shuffling a string is funny but without much use. Nevertheless,
shuffling apply to any kind of collection, not only to string, and it
proves to be of some use as we may see later:
@smalltalkExample{'hello world' shuffled
@result{} 'wod llreohl'}

@cindex string, @msg{sorted}
We can write the same about sorting a string:
@smalltalkExample{'bonjour' sorted
@result{}#($b $j $n $o $o $r $u)}

@subsection Fun with variables
@cindex variable
How a variable can be fun? With @cuis{}, a variable is the name of a box
that holds a value. A variable can hold a value of any class.
The value is strongly typed (we can always determine its Class), but the
variable (box) is not restricted to holding a value of a single type.

To declare a variable we name it at the beginning of the script
and surround it by pipe charaters ``|''.

So far we sent messages directly to objects, we can send message to a
variable bound to an object too.

Any object responds to the message #printString.

@smalltalkExample{| msg |
msg := 'hello world!'.
Transcript show: msg capitalized printString, ' is a kind of '.
Transcript show: msg class printString; newLine.
msg := 5.
Transcript show: msg printString, ' is a kind of '.
Transcript show: msg class printString; newLine.}

@strong{Caution.} This ease of use has a drawback: when sending a
message to a variable bound to an object, the system does not check
that the object understands the message. Nevertheless there is a procedure
to catch this kind of situation.

@subsection Fun with collections
A Collection is a grouping of objects. Arrays and Lists are collections.  
A @class{String} is a collection of characters.
Many kinds of Collection have similar behaviors.

@cindex array
@class{Array} is a fixed size collection, contrary to string it can
contain any kind of literal enclosed in @smalltalk{#(@tie{})}:
@smalltalkExample{"array of numbers"
#(1 3 5 7 11 1.1)
"array of mixed literals"
#(1 'friend' $& 'al')}

Using non literal expression in the array will not work as expected:
@smalltalkExample{#(1 2/3)
@result{} #(1 2 #/ 3)}

@cindex array, dynamic
Indeed, the ``/'' is interpreted as a literal symbol and
@smalltalk{2/3} is not interpreted as a fraction. To get a fraction
inserted in the array, you use a @dfn{run-time array} or @dfn{dynamic
array}, its elements are expressions separated by dot and surrounded
with @smalltalk{@{ @}}:

@smalltalkExample{@{1 . 2/3 . 7.5@}
@result{} #(1 2/3 7.5)}

@cindex array, operation
@cindex array, size
With an array filled with numbers you can request information and
arithmetic operations:
@smalltalkExample{#(1 2 3 4) size @result{} 4
#(1 2 3 4) + 10 @result{} #(11 12 13 14)
#(1 2 3 4) / 10 @result{} #(1/10 1/5 3/10 2/5)}

@cindex collection, @msg{squared}
Mathematics operations work as well:
@smalltalkExample{#(1 2 3 4) squared @result{} #(1 4 9 16)
#(0 30 45 60) degreeCos
@result{} #(1.0 0.8660254037844386
0.7071067811865475 0.49999999999999994)}

@cindex array, statistic
Basic statistic methods can be used directly on array of numbers:

@smalltalkExample{#(7.5 3.5 8.9) mean @result{} 6.633333333333333 
#(7.5 3.5 8.9) range @result{} 5.4
#(7.5 3.5 8.9) min @result{} 3.5
#(7.5 3.5 8.9) max @result{} 8.9}

To get an array of natural numbers from 1 to 100, we use the keyword
message @msg{to:}

@smalltalkExample{(1 to: 100) asArray
@result{} #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45
46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91
92 93 94 95 96 97 98 99 100)}

In this line of code, the message @msg{to:} is sent to @smalltalk{1}
with the argument @smalltalk{100}. It returns an interval object. The
message @msg{asArray} sent to the interval returns an array.

@exercise{Negative integer numbers,exeNegativeIntegers,@emph{Create an
array of integer numbers ranging from -80 to 50.}}

@c introduce ordered collection
@cindex collection, dynamic
@cindex collection, @class{OrderedCollection}
@cindex collection, @msg{add:}
The size of n array is fixed size, it can not grow. An
@class{OrderedCollection} is a dynamic, ordered collection, it grows
when adding element with the @msg{add:} message:
@smalltalkExampleCaption{Dynamic size collection,dynamicSize,
| fibo | 
fibo := OrderedCollection newFrom: #(1 1 2 3).
fibo add: 5;
   add: 8;
   add: 13;
   add: 21.
fibo
@result{} an OrderedCollection(1 1 2 3 5 8 13 21)}

@cindex collection, @msg{at:}
@cindex collection, @msg{last}
@cindex collection, @msg{indexOf:}
Index access to the elements of a collection is done with a variety of
messages. The index naturally ranges from 1 to the collection size:
@smalltalkExample{fibo at:1 @result{} 1
fibo at: 6 @result{} 5
fibo last @result{} 21
fibo indexOf: 2 @result{} 3
fibo at: fibo size @result{} 21}


@subsubheading Playing with enumerators
The collection comes with a set of helpful methods named
enumerators. They operate one each element of a collection.

@cindex collection, set operations (union, intersection, difference)
Set operations between two collections are computed with the
@msg{union:}, @msg{intersection:} and @msg{difference:} messages.
@smalltalkExampleCaption{Set operations,setOpe,
#(1 2 3 4 5) intersection: #(3 4 5 6 7)
@result{} #(3 4 5)
#(1 2 3 4 5) union: #(3 4 5 6 7)
@result{} a Set(5 4 3 2 7 1 6) 
#(1 2 3 4 5) difference: #(3 4 5 6 7)
@result{} #(1 2)}

@exercise{Hole in a set,holeSet,@emph{Construct the array of the
numbers 1@comma{}...@comma{}24@comma{}76@comma{}...@comma{}100.}}

Set operation works with any kind of content. We will discuss
comparing objects later.
@smalltalkExample{#(1 2 3 'e' 5) intersection: #(3.0 4 6 7 'e')
@result{} #(3 'e')}

@cindex collection, @msg{select:}
@cindex collection, enumerator mechanism
@cindex block
To select the prime numbers from 1 to 100, we use the @msg{select:}
enumerator. This message is sent to a collection, then it will select
each element of the collection returning true to a test condition:

@smalltalkExampleCaption{Select prime numbers between 1 and 100,prime100,
(1 to: 100) select: [:n | n isPrime]
@result{}  #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71
73 79 83 89 97)}

This example introduces the message @msg{select:} and block of code, a
primordial constituting element of the @cuis{} model. A block of code,
delimited by square brackets, is a piece of code for later
execution(s). Let's explain how this script is executed:

@itemize

 @item @smalltalk{(1 to: 100)} is evaluated as an interval

 @item the block of code @smalltalk{[:n | n isPrime]} is instantiated (created)

 @item the message @msg{select:} is sent to the interval with the
 block of code as argument

 @item for each integer of the interval, the block of code is executed
 with its parameter @smalltalk{n} set to the integer value. Then, each
 time @smalltalk{n isPrime} evaluates to true, the @smalltalk{n} value
 is added to a new collection answered when the @smalltalk{select:}
 method finished testing each element of the collection.

@end itemize

Enumerators are tremendously powerful to process collection without
the need of index.

@exercise{Odd integers,oddNumbers,@emph{Select the odd number between
-20 and 45.}}

You want to know the quantity of prime numbers under 100.  Just send
the message @msg{size} to the answered collection at
@ref{prime100}. The parenthesis are mandatory to ensure the @msg{size}
is sent last to the resulting collection:
@smalltalkExampleCaption{Number of prime numbers between 1 and
100,qtyPrime100, ( (1 to: 100) select: [:n | n isPrime] ) size
@result{} 25}

For more clarity, we use a variable named @smalltalk{primeNumbers} to
remembers about the prime numbers list we build:
@smalltalkExample{| primeNumbers |
primeNumbers := (1 to: 100) select: [:n | n isPrime].
primeNumbers size}

@exercise{Number of prime number between 101 and
200,qtyPrime200,@emph{Modify @ref{qtyPrime100} to calculate the number
of prime numbers between 101 and 200.}}

@exercise{Multiple of 7,multiples7,@emph{Build the list of the
multiples to 7 bellow 100}}

@exercise{Odd and non prime integers,oddNonPrime,@emph{Build a
collection of the odd integers in [1 ; 100] which are not prime.}}

@cindex collection, @msg{collect:}
A sister enumerator to @msg{select:} is @msg{collect:}. It returns a
new collection of the same size, with each element transformed by a
block of code. When searching perfect cubic roots, it is useful to
know about some cubes:

@smalltalkExampleCaption{Collect cubes,cubesCollect,
(1 to: 10) collect:[:n | n cubed]
@result{} #(1 8 27 64 125 216 343 512 729 1000)}

The collected elements can be of a different type. Bellow, a string is
enumerated and integers are collected:

@smalltalkExample{'Bonjour' collect: [:c | c asciiValue ]
@result{}  #(66 111 110 106 111 117 114)}

We can shift the ascii value, convert back to character then collect
in a new string. It is a simple cipher:
@smalltalkExampleCaption{Simple cipher,simpleCipher,
'Bonjour' collect: [:c | (c asciiValue + 1) asCharacter ]
@result{} 'Cpokpvs'}

@exercise{Cipher decode,decodeCipher,@emph{Write the script to decode
cipher 'Zpvs!bsf!cptt', it was encoded with @ref{simpleCipher}}}

@cindex Caesar cipher
The Caesar's cipher is based on shifting letter to the right in the
alphabet order.  The method is named after Julius Caesar, who used it
in his private correspondence with a shift of 3.

@exercise{Alphabet Caesar's cipher,alphabetCipher,@emph{Write a script
to collect the upper letters representing the Caesar's cipher. The
expected answers is} #($D $E $F $G $H $I $J $K $L $M $N $O $P $Q $R $S
$T $U $V $W $X $Y $Z $A $B $C)}

Once you get the alphabet cipher right, you can encode your first
message:
@exercise{Encode with Caesar's cipher,encodeCaesar,@emph{Encode the
phrase 'SMALLTALKEXPRESSION'.}}

And decode message:
@exercise{Decode with Caesar's cipher,decodeCaesar,@emph{Decode the
message 'DOHDMDFWDHVW'.}}

@subsubheading Fun with loops
Collection can be iterated with traditional loops: there is a whole
family of @emph{repeat}, @emph{while} and @emph{for} loops.

@cindex loop, for
@cindex for loop
A simple @emph{for} loop between two integer values is written with
the keyword message @msg{to:do:}, the last argument is a block of code
executed for each index:
@smalltalkExampleCaption{A @emph{for} loop,forLoop,
| sequence |
sequence := OrderedCollection new.
1 to: 10 do: [:k | sequence add: 1 / k].
sequence
@result{} an OrderedCollection(1 1/2 1/3 1/4 1/5 1/6 1/7 1/8 1/9 1/10)}

A collect writes more concisely, though:
@smalltalkExample{(1 to: 10) collect: [:k | 1/k]}

To step with a different value than 1, a third numeric argument is
inserted:
@smalltalkExample{1 to: 10 by: 0.5 do: [:k | sequence add: 1 / k]}

@cindex loop, repeat
@cindex repeat
@cindex Fibonacci sequence
A repeated loop without index or any collection is written with the
@msg{timesRepeat:} message:
@smalltalkExampleCaption{A @emph{repeat} loop, repeatLoop,
| fibo |
fibo := OrderedCollection newFrom: #(1 1).
10 timesRepeat: [
   fibo add: (fibo last + fibo atLast: 2)].
fibo
@result{} an OrderedCollection(1 1 2 3 5 8 13 21 34 55 89 144)}

The quotient of consecutive Fibonacci terms converge toward the golden
value:
@smalltalkExample{fibo pairsDo: [:i :j |
   Transcript show: (j / i ) asFloat ; cr]
@result{} 1.0
@result{} 1.5
@result{} 1.6
@result{} 1.6153846153846154
@result{} 1.6176470588235294
@result{} 1.6179775280898876}

@c A graph to show the progression of Qty of prime number 100 large interval integer 

@node Introduction to the system classes
@section Introduction to the system classes
@cuis{} is a pure object oriented language: all the entities as
integer, float, rational number, string, collection, block of code we
discovered in the previous section are objects.

@subsection Understanding Object Oriented Programming
But what is an object?  An object is an entity responding to two
criteria:

@itemize

   @item @strong{An internal state.} It is embodied by variable(s)
   known only by the object. A variable only visible within the object
   is called @dfn{private}. As a consequence, it is impossible -- if
   the object decides so -- to know the internal state of the object
   from another object.

   @item @strong{A behavior.} It is modeled by message(s) -- we
   already used this vocabulary -- sent to the object. When the object
   receives a message it understands, it executes the code of an
   internal method named as the message.

@end itemize
@cindex class
@cindex subclass
@cindex instance

Several entities sharing the same variables and understanding the same messages
are very likely to exist within @cuis{} -- think about the
numbers. Therefore, entities are created -- @dfn{instantiated} --
following a model, this model is called a @dfn{Class}.

A specific class declares the internal variables and the behavior by
implementing the methods. Let see how the @class{Fraction} class is
declared:

@smalltalkExample{Number subclass: #Fraction
   instanceVariableNames: 'numerator denominator'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Kernel-Numbers'}

As expected there are two variables -- named @dfn{instance variables}
-- to define the @smalltalk{numerator} and @smalltalk{denominator} of
a fraction. From this declaration, we observe there is a hierarchy in
the class definition: @class{Fraction} is a kind of
@class{Number}. This means a fraction inherits the internal state --
variables -- and behavior -- methods -- defined in the @class{Number}
class. @class{Fraction} is called a @dfn{subclass} of @class{Number}.

@cindex class, inheritance
A Class specifies the behavior of all of its instances.  It is useful 
to be able to say "this object is like that object, but for these differences".  
We do this in Smalltalk by a Class inheriting instance state and behavior from 
its parent Class.  This child, or subclass then specifies just the
instance state and behavior which is different from its parent.

This aspect of object oriented programming is called
@dfn{inheritance}. In @cuis{}, each class inherits from one parent
class.

In Smalltalk, each object decides for itself how it reponds to a message.
This is called @dfn{polymorphism}.
The same message selector may be sent to objects of different Classes.  
The 'shape' (morph) of the computation is different depending on the specific 
class of the 'many' (poly) possible classes of the object receiving the message.

We saw above that different kinds of objects
all responded to the same #printString message in different,
but appropriate ways.

@c instance creation
@cindex instance, creation
@cindex class, class method
In the previous section, we already met fraction. Those fractions are
objects called @dfn{instance} of the class @class{Fraction}. To create
this instance we wrote @smalltalk{5 / 4}, the mechanism is based on
message sending and polymorphism. The number @smalltalk{5} is an
integer receiving the message @msg{/}, therefore looking at the method
@method{/} in the @class{Integer} class explains how is instantiated
the fraction. See part of this method:
@smalltalkExample{/ aNumber
"Refer to the comment in Number / "
| quoRem |
aNumber isInteger ifTrue:
../..
   ifFalse: [^ (Fraction numerator: self denominator: aNumber) reduced]].
../..}

From this source code, we learn that in some situation, the method
returns a fraction, reduced. We can expect that in some other
situation an integer is returned, for example @smalltalk{6 / 2}.

In the example, we observe the message @msg{numerator:denominator:} is
sent to the class @class{Fraction}, such a message refers to a
@dfn{class method} understood only by the @class{Fraction} class. It
is expected such a named method returns an instance of a
@class{Fraction}.

Try out in a workspace:
@smalltalkExample{Fraction numerator: 24 denominator: 21
@result{} 24/21}

Observe how the fraction is not reduced. Whereas it is, when
instantiated with the @msg{/} message:

@smalltalkExample{ 24 / 21
@result{} 8/7}

A class method is often used to create a new instance from a class. In
@ref{forLoop}, the message @msg{new} is sent to the class
@class{OrderedCollection} to create a new empty collection;
@method{new} is a class method.

In @ref{repeatLoop}, the @msg{newFrom:} message is sent to the class
@class{OrdredCollection} to create a new collection filled with
elements from the array given in argument; @method{newFrom:} is
another class method.

@c instance method
@cindex class, instance method
@cindex polymorphism
@cindex number, @msg{squared}
Now observe the hierarchy of the Number class:

@format
@class{Number}
   @class{Float}
      @class{BoxedFloat64}
      @class{SmallFloat64}
   @class{Fraction}
   @class{Integer}
      @class{LargePositiveInteger}
         @class{LargeNegativeInteger}
      @class{SmalltalkInteger}
@end format

@class{Float}, @class{Integer} and @class{Fraction} are direct
descendants of the @class{Number} class. We already learnt about the
@msg{squared} message sent to integer and fraction instances:

@smalltalkExample{16 squared @result{} 256
(2 / 3) squared @result{} 4/9}

As the @msg{squared} message is sent to @class{Integer} and
@class{Fraction} instances, the associated @method{squared} method is
called an @dfn{instance method}. This method is defined in both the
@class{Number} and @class{Fraction} classes.


Let's examine this method in @class{Number}:
@smalltalkExample{Number>>squared
"Answer the receiver multiplied by itself."
   ^self * self}

In an instance method source code, @smalltalk{self} refers to the
object itself, here it is the value of the number. The @smalltalk{^}
symbol indicates to return the following value @smalltalk{self *
self}.

Now let's examine this same method in @class{Fraction}:
@smalltalkExample{Fraction>>squared
   ^ Fraction
      numerator: numerator squared
      denominator: denominator squared}

Here a new fraction is instantiated with numerator and denominator
squared. This alternate @method{squared} method, ensure a fraction is
returned.

@cindex method, overriding
@cindex overriding
When message @msg{squared} is sent to a number, different methods are
executed depending on the number is a fraction or any other kind of
number. This fundamental mechanism of oriented object programming is
called @dfn{Polymorphism}. More precisely, the @class{Fraction} class
is @dfn{overriding} the @method{squared} method, defined above in the
class hierarchy.

@cindex number, @msg{abs}
Still in the @class{Number} hierarchy, let's examine another example
of polymorphism with the @msg{abs} message:

@smalltalkExample{-10 abs @result{} 10
5.3 abs @result{} 5.3
(-5 / 3) abs @result{} 5/3}

The implementation in @class{Number} does not need much
explanation. There is the @msg{ifTrue:ifFalse:} we have not yet
discussed so far, but the code is quite self-explanatory:

@smalltalkExample{Number>>abs
"Answer a Number that is the absolute value (positive magnitude) of the 
receiver."
   self < 0
      ifTrue: [^self negated]
      ifFalse: [^self]}

This implementation will do just fine for the @class{Number}
subclasses. Nevertheless, there are several classes overriding it for
optimization purpose.

For example, regarding large positive integer, @method{abs} is
empty. Indeed, in the absence of explicitly returned value, the
default returned value is the instance itself, in our situation the
@class{LargePositiveInteger} instance:

@smalltalkExample{LargePositiveInteger>>abs}

The @class{LargeNegativeInteger} counter part compute the opposite
with @msg{negated} message:

@smalltalkExample{LargeNegativeInteger>>abs
   ^ self negated}
   
These two overriding methods are more efficient as they avoid test and
ifTrue/ifFalse branches. Polymorphism is often used to avoid test and
branching, it is done at the object level.

As an object is modeled against a class, it is possible to ask its
class with the @msg{class} message. Observe carefully the class
returned in line 2 and 3:

@smalltalkExampleCaption{Asking the class of an instance,askingClass,
1 class @result{} SmallInteger 
(1/3) class @result{} Fraction 
(6/2) class @result{} SmallInteger 
(1/3) asFloat class  @result{} SmallFloat64 
(1.0/3) class @result{} SmallFloat64 
'Hello' class @result{} String 
('Hello' at: 1) class @result{} Character}

To ease the exploration of the system classes, we will first introduce
the system browser, a central tool to @cuis{} oriented object
programming.

@cindex tools, system browser
@cindex browser
@subsection A brief introduction to the system browser
The @dfn{System Browser}, in short the @dfn{Browser}, is a tool to
rule all the classes in @cuis{}. It is both a tool to explore the
classes (system or user ones) and to write new classes and methods.

To access the tool, ...@clicksequence{Background click @click{}
Open... @click{} Browser}...

@figure{The System Browser,B-01-browserDetailed,12}

@cindex browser, class category
At the top left are the @dfn{class categories}, there are group of
classes part of the same theme. It is also called @dfn{Package}, it is
an organisational element to save code. In @ref{B-01-browserDetailed}, the
selected class category is @option{Kernel-Numbers}, a group of
classes we already explored. The term @option{Kernel-} indicates it
is part of fundamental categories, but it is only a convention. See
the other categories as @option{Kernel-Text} and
@option{Kernel-Chronology} related to text and date entities.

@cindex class, declaration
Next to the right are the classes in the selected class category. They
are nicely presented in a parent-child class hierarchy. When a class is
first selected in this pane, its declaration appears in the large pane
bellow, the @class{Number} class declaration is:

@smalltalkExample{Magnitude subclass: #Number
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Kernel-Numbers'}

Observe a few important points in this declaration:

@itemize

   @item @class{Number} is a sub class of @class{Magnitude}

   @item the declaration itself is Smalltalk code, indeed the message
   @msg{subclass:instanceVariableNames:classVariableNames:poolDictionaries:
   category:} is sent to @class{Magnitude}

   @item the @smalltalk{subclass:} argument @class{Number} is prefixed
   with ``#'', it is a symbol, a kind of unique string. Indeed when
   declaring the @class{Number} class, the system does not know it
   yet, so it is named as a symbol.

   @item The @smalltalk{instanceVariableNames:} argument is a string:
   the instance variables of the class are declared by name separated
   by a space.

@end itemize

Next to the right is the method categories panel. It is user defined
method categories. A class can come with tenth of methods, grouping
them by category ease the user access. As a reference, @class{Number}
has more than 100 instance side methods implemented in
itself@footnote{When considering its parents, the count is greater
than 300.}; therefore clicking the @option{arithmetic} category
directly gives access to related methods in the next and last pane at
the right.

@exercise{Count of methods,stringArith,@emph{How many methods is there
in the @option{arithmetic} method category of the @class{String}
class?}}

@c explain mini panel | instance | ? | class |
In @ref{B-01-browserDetailed}, bellow the classes pane, there are three
buttons:

@itemize

   @item @option{instance}: to access the @strong{instance methods} of
   the selected class. For the recall, these methods are only
   accessible from the instances of the class.

   @item @option{?}: to access to documentation -- comment -- of the
   selected class.

   @item @option{class}: to access the @strong{class methods} of the
   selected class. These methods are only accessible from the class
   itself.

@end itemize

Below these three buttons, observe the wide text pane, it provides
contextual information on the selected item.

@exercise{Float class information, floatInfo, @emph{When the
@class{Float} class is selected, what is the information provided by
the text pane?}}

It is important to distinguish instance methods and class
methods. Let's consider the @class{Float} class as an example.

@cindex class, class method
@strong{Class Methods.} In @ref{B-01-floatClassSide} the methods listed are
class side, in the browser the @option{class} button is pressed to see this
list. From a Workspace, this methods are called with the message name
sent directly to the class:

@smalltalkExample{Float e
@result{} 2.718281828459045
Float epsilon
@result{} 2.220446049250313e-16
Float fmax
@result{} 1.7976931348623157e308}

Nevertheless, you can not send this message to instance of
@class{Float}, it throws an error and opens the red debugger window.

Just close the debug window for now to ignore the result.
We will look into this in more detail later.

@smalltalkExample{3.14 pi
@result{} MessageNotUnderstood: SmallFloat64>>pi
Float pi e
@result{} MessageNotUnderstood: SmallFloat64>>e}

Often these class methods are used to access constant value as seen in
the previous example or to create a new instances:

@smalltalkExample{OrderedCollection new
@result{} Create a new empty ordered collection
Fraction numerator: 1 denominator: 3
@result{} 1/3 a fraction instance
Float new
@result{} 0.0
Float readFrom: '001.200'
@result{} 1.2 
Integer primesUpTo: 20
@result{} #(2 3 5 7 11 13 17 19) }

@figure{Class methods in @class{Float},B-01-floatClassSide,5}

@cindex class, instance method
@strong{Instance methods.} In @ref{B-01-floatInstanceSide}, the methods
listed are instance side, in the browser the @option{instance} button
is pressed to see this list. In a Workspace, this methods are called
with the message name sent directly to an instance:

@smalltalkExample{-10.12 abs @result{} 10.12
3.14 cos @result{} -0.9999987317275395
-10.12 * 2 @result{} -20.24}

Instance method message can not be sent directly to a class, you need
to instantiate first an object:

@smalltalkExample{Float cos
@result{} MessageNotUnderstood: Float class>>cos
Fraction squared
@result{} MessageNotUnderstood: Fraction class>>squared
OrderedCollection add: 10
@result{} MessageNotUnderstood: OrderedCollection class>>add:}

Of course you can mix both class and instance methods, as long as you
send the message to the appropriate class or instance:

@smalltalkExample{Float pi cos
@result{} -1.0
Float e ln
@result{} 1.0 
(Fraction numerator: 4 denominator: 5) squared
@result{} 16/25
OrderedCollection new add: Float pi; add: Float e; yourself
@result{} an OrderedCollection(3.141592653589793 2.718281828459045) 
}

@figure{Instance methods in @class{Float},B-01-floatInstanceSide,7}

@cindex browser, invoke from workspace
A last bit of advice,  in the workspace when requesting the
class of an instance, @kbd{Ctrl-b} will invoke the browser on the
returned class:

@itemize

   @item In the workspace, on @smalltalk{1 class} execute and print
   with @kbd{Ctrl-p},

   @item @class{SmallInteger} is printed and automatically selected by default,

   @item Invoke the browser on the selected @class{SmalltalkInteger}
   class with @kbd{Ctrl-b},

   @item The browser is open on the @class{SmalltalkInteger}, ready to
   be explored.

@end itemize

With this brief introduction to the system browser, your are now
equipped to explore the system classes.

@subsection @cuis{} system classes
As we already wrote @cuis{} is a pure object oriented environment. It
means that every single entities you are dealing with are represented
as instances of classes written in @cuis{} itself. As a direct
consequence, @cuis{} is mostly written in itself.  In the previous
section we read some details of the @class{Fraction} class and both
instance and class side methods (@method{abs}, @method{squared} and
@method{numerator:denominator:}.

What we call system classes are models of fundamental objects. In
other programming languages, it will be called standard library.

To be honest, there is no such a distinction between system classes
and user classes, but it will help us to draw a boundary around the
most used objects. We will give a brief introduction to these classes
and the most important methods, part two gives a more detailed
presentation.

The classes are organised in hierarchy grouped in categories. To
discover the most important classes, we use the browser to navigate
these categories in the left pane. Important categories to start with
are:


@itemize

   @item @option{Kernel-Numbers}. Related to the different number
   representations and calculated, including mathematics functions,
   conversion, intervals and even iterations.
   
   @item @option{Kernel-Text}. Related to character and string as
   collection of characters.
   
   @item @option{Collections-Abstract},
   @option{Collections-Unordered}, @option{Collections-Sequenceable},
   @option{Collections-Arrayed}. Related to Array, Dictionary, dynamic
   collection as OrderedCollection and many more. It includes
   accessing, enumerators, mathematics functions, sorting.

@end itemize


@subsubsection Kernel-Numbers
The top hierarchy @class{Number} class shows most of the behaviors
inherited by the sub classes as @class{Float}, @class{Integer} and
@class{Fraction}. The Smalltalk way to learn about a behavior is to
point the System Browser toward a top hierarchy class and to explore
the method categories.

Let's suppose we want to round a float number. In @class{Number}, we
explore the @option{Truncation and round off} method category to
discover several behaviors. The next things to do, is to test these
messages in a Workspace to discover the one we are searching for:

@smalltalkExampleCaption{Rounding numbers@comma{} Workspace try out, roundingNumbers,
1.264 roundTo: 0.1 @result{} 1.3 
1.264 roundTo: 0.01 @result{} 1.26 
1.264 roundUpTo: 0.01 @result{} 1.27
1.264 roundTo: 0.001 @result{} 1.264}


@cindex loop, for
@cindex for loop
Number is a very strange place to look for an indexed loop in a given
interval. Nevertheless, an interval is defined by start and stop
numbers. In the @class{Number} class, the method category
@option{intervals} reveals related behaviors, we already met some of
them. These methods works indifferently with all kind of number:

@smalltalkExampleCaption{Interval loops (for-loop), intervalLoops,
1 to: 10 do: [:i | Transcript show: 1 / i; space]
@result{} 1 (1/2) (1/3) (1/4) (1/5) (1/6) (1/7) (1/8) (1/9) (1/10)

1 to: 10 by: 2 do: [:i | Transcript show: 1 / i; space]
@result{} 1 (1/3) (1/5) (1/7) (1/9)

1/10 to: 5/3 by: 1/2 do: [:i | Transcript show: i; space]
@result{} (1/10) (3/5) (11/10) (8/5) (1/10) (3/5) (11/10) (8/5) 

Float pi to: 5 by: 1/3 do: [:i | Transcript show: (i roundTo: 0.01) ; space]
@result{} 3.14 3.47 3.81 4.14 4.47 4.81}

@cindex loop, repeat
@cindex repeat
Now, in the @class{Integer} class, explore the method category
@option{enumerating}, here is the @method{timesRepeat:}. When a
portion of code needs to be executed several times
@footnote{Understand repeated an integer number of times.}, without
the need of an index, the @msg{timesRepeat:} message is sent to an
integer. We already saw this variant in a previous section of this
chapter.  Throwing 5 times a 6 faces dice can be simulated with
integer:

@smalltalkExampleCaption{Throwing a dice 5 times, playingDice,
5 timesRepeat: [Transcript show: 6 atRandom; space]
@result{} 1 2 4 6 2}

@exercise{Cosine table,cosTable, @emph{Compute the cosine values in
the interval [0 ; 2PI]@comma{} each 1/10. Output in the transcript.}}

@c Integer bits representation and manpulation
@cindex number, base
Integer numbers are represented in different bases when prefixed with
the base and ``r''. When executing and printing @kbd{Ctrl-p} such a
number, it is immediately printed in the decimal base:

@smalltalkExampleCaption{Integer represented in different base,integerBase,
2r1111 @result{} 15
16rF @result{} 15
8r17 @result{} 15
20rF @result{} 15
10r15 @result{} 15}

Writing numbers as Mayans or Babylonians@footnote{Bases 20 and 60
number representation are not exclusive to these civilisations,
although there are the most documented use cases.}:

@smalltalkExampleCaption{Counting like the ancients,countingAncients,
"The Babylonians"
60r10 @result{} 60
60r30 @result{} 180
60r60 @result{} 360
60r30 + 60r60 @result{} 540 
(60r30 + 60r60) printStringRadix: 60 @result{} '60r90' 

"The Mayans"
20r10 @result{} 20
20r40 @result{} 80 "pronounced 4-twenties in some languages"
20r100 @result{} 400}

@cindex integer, bits shifting
Because of the nature of a number represented in base 2, shifting its
bits left and right is equivalent to multiplying by 2 and dividing by
2:

@smalltalkExampleCaption{Shifting bits, shiftBits,
(2r1111 << 1) printStringBase: 2 @result{} '11110'
2r1111 << 1 @result{} 30
(2r1111 >> 1) printStringBase: 2 @result{} '111'
2r1111 >> 1 @result{} 7}

@exercise{Multiply by 1024,multiplyBy1024, @emph{How will you multiply
the integer 360 by 1024@comma{} without using the multiplication operation?}}


@subsubsection Kernel-Text
Notably, this category comes with @class{Character}, @class{String}
and @class{Symbol}. @class{String} instance are collection of
@class{Character} instances.

@cindex character
@strong{Character.} An individual character is written prefixed with a
``$'': @smalltalk{$A}. It can be defined with the class side method
@method{numericValue:} or converted from an integer instance with the
@msg{asCharacter}:

@smalltalkExample{Character numericValue: 65 @result{} $A
65 asCharacter @result{} $A}

There are class side methods for non printable characters:
@smalltalk{Character tab}, @smalltalk{Character lf}, etc.

As string are collection of characters, when enumerating a string we
can use the @class{Character} instance methods:

@smalltalkExampleCaption{Twelve apples,apples12,
'There are 12 apples.' select: [:c |c isDigit].
@result{} '12'}

@exercise{Select apples,selectApples, @emph{Modify @ref{apples12} to
reject the numeric characters.}}

@cindex string
@strong{String.} @class{String} is a very large class, it comes with
more than 200 methods. Hopefully the methods are grouped in categories
and it is very easy to experiment from a Workspace when you are
looking for a specific behavior.

Consider you need to search for a string in a string: when browsing
the @class{String} class, search for method categories named like
@option{finding...} or @option{accessing}. There you find a family of
@method{findXXX} methods. Read the comments at the beginning of these
methods:

@smalltalkExample{findString: subString
   "Answer the index of subString within the receiver, starting at
   start. If the receiver does not contain subString, answer 0."
   ^self findString: subString startingAt: 1.}

Or:

@smalltalkExample{findString: key startingAt: start caseSensitive: caseSensitive
   "Answer the index in this String at which the substring key first
   occurs, at or beyond start.  The match can be case-sensitive or
   not.  If no match is found, zero will be returned."
   ../..}

Then experiment the potentially interesting messages in a workspace:

@smalltalkExample{'I love apples' findString: 'love' @result{} 3 "find at position 3"
'I love apples' findString: 'hate'
@result{}  0 "no finding"
'We humans, we all love apples' findString: 'we'
@result{} 12 
'We humans, we all love apples'
   findString: 'we'
   startingAt: 1
   caseSensitive: false
@result{} 1 
'we humans, we all love apples' findString: 'we'
@result{} 1 
'we humans, we all love apples' findString: 'we' startingAt: 2
@result{} 12}

Following these paths will, most of the time, leads you to the answer
you are looking for.

@c an exercise to find a method given a behavior
@exercise{Format a string, formatString, @emph{We want to format a
string of the form 'Joe bought XX apples and YY oranges' to the form
'Joe bought 5 apples and 4 oranges'. What message should be used?}}

@c browse the hierarchy to find more inherited behavior, Should this
@c be documented in browser section, or just there
@cindex class, inheritance
@cindex class, protocol
@cindex protocol

The @class{String} also inherits its behavior from its ancestors,
parent classes. Indeed a @class{String} is a subclass of
@class{ArrayedCollection}. The direct consequence is that when
searching for some specific behavior, you may need to explore the
parent classes too. The whole behavior of a class, defined in the
class itself and its parents is named its @dfn{protocol}.

@cindex browser, hierarchy
@cindex browser, protocol
Again the browser is helpful to explore a class protocol. You have two
options:

@enumerate

   @item @strong{Explore the protocol.} In the class pane of the
   browser, do ...@clicksequence{select @class{String} class @click{}
   click the right mouse button @click{} in the menu select
   @option{Browse protocol (p)}}... Alternatively, use the keyboard
   shortcut @kbd{Ctrl-p}.

   @figure{Browse @class{String} protocol,B-01-browseProtocol,8}

   The new window is a protocol browser for the @class{String}
   class. At the left, a hierarchy of the @class{String} ancestors;
   selecting one class there only shows the protocol starting from
   this class down to the @class{String} class. In the pane at the
   right is the list of methods of the selected ancestry. The specific
   protocol to @class{String} is bold; surrounded by parenthesis, the
   class the method is implemented in.

   In @ref{B-01-browseProtocol}, no specific class is selected,
   therefore the whole @class{String} protocol is listed at the
   right. The method @method{before:} implemented in
   @class{SequenceableCollection} is selected and its source code is
   displayed on the large bottom pane.

   @item @strong{Explore the hierarchy.} In the class pane of the
   browser, do ...@clicksequence{select @class{String} class @click{}
   click the right mouse button @click{} in the menu select
   @option{Browse hierarchy (h)}}... Alternatively, use the keyboard
   shortcut @kbd{Ctrl-h} or the button @option{hierarchy} on the
   system browser.

   @figure{Browse the @class{String} hierarchy,B-01-browseHierarchy,8}

   The hierarchy browser is very like the system browser with only two
   differences:

   @itemize

      @item At the far left, the class categories pane is absent,
      
      @item In the classes pane, the hierarchy of @class{String} is
      printed. It makes easy to browse @class{String} parents and
      children class.

   @end itemize

@end enumerate

The hierarchy browser is a general tool for exploration. Contrary to
the protocol browser, it does not display at once the whole protocol
of a class. In @ref{B-01-browseHierarchy}, the class
@class{SequenceableCollection} is selected as well as its method
@method{before:}.

This method extracts from a collection the element before a specified
element. When inherited in @class{String}, those elements are
@class{Character} instances:

@smalltalkExample{'1 + 3i' before: $i
@result{} $3 
}

Practice the tools and resolve the exercise bellow.

@exercise{Cut a string, cutString,@emph{Find the appropriate
method to transform 'Hello My Friend' in 'My Friend'?}}

Beware, some messages in the @class{String} protocol may obviously not
work. Observe bellow, the error is thrown on a @class{Character}
instance:

@smalltalkExample{'Hello My Friend' cos
@result{} MesageNotUnderstood: Character>>cos}

@cindex symbol
@strong{Symbol.} A symbol is very like a string but it is unique and
never duplicated. It is written as @smalltalk{#hello}, and often used
as a constant. You already observe how in the book we noted messages
as symbol, it is because each message is unique. You will use symbol
when you need to name something uniquely.

Observe in the example bellow, the strings are not identical once
duplicated -- understand not the same memory location in the computer
-- however symbols are identical even when duplicated@footnote{To be
honest, copying a symbol just returns the original symbol.}:

@smalltalkExample{'hello' == 'hello' copy
@result{} false 
#hello  == #hello copy
@result{} true}

Symbols can be written with space:

@smalltalkExample{Symbol with space character,symbolSpace,
#'hello my friend'
'hello my friend' asSymbol}

@class{Symbol} is a sub class of @class{String}, a lot of its behavior
is inherited. It is helpful to make handy symbol:

@smalltalkExample{'hello my friend' asCamelCase asSymbol 
@result{} #helloMyFriend}

@subsubsection Collections
@cindex collection
The @option{Collections-} class categories are the most prolific,
there are 7 of them gathering 46 classes.

@c explain category Collections-Abstract
@cindex class, abstract
The category @option{Collections-Abstract} groups classes which are
said to be abstract. An @dfn{abstract} class cannot be instantiated,
its behavior is declared but not completely implemented. It is the
responsibility of its sub classes to implement the missing part of the
behavior. Observe how the important @method{do:} method is declared
but not implemented:

@smalltalkExample{Collection>>do: aBlock 
"Evaluate aBlock with each of the receiver's elements as the argument."
self subclassResponsibility}

Then observe how two different @class{Collection} sub classes
implement it:

@smalltalkExample{OrderedCollection>>do: aBlock 
firstIndex to: lastIndex do: [ :index |
   aBlock value: (array at: index) ]}

and:

@smalltalkExample{Dictionary>>do: aBlock
super do: [:assoc | aBlock value: assoc value]}

@c distinguish growable and non-growable collection Array (Collections-Arrayed) and OrderedCollection
@c (Collections_Sequenceable)

Two groups of collections must be distinguished: collection with a
fixed size and collection with a variable size.

@cindex collection, fixed size
@strong{Collection of fixed size.}  Such collections are gathered in
the category @option{Collections-Arrayed}. The most notable one is
@class{Array}, its size -- the number of elements it can hold -- is
set when creating the instance. Once instantiated, you can not add nor
delete elements to an array.

@cindex collection, instantiate array
@cindex @class{Array}

There are different ways to create @class{Array} instance:

@smalltalkExampleCaption{Collection with a fixed size,createArray,
array1 := #(2 'Apple' $@@ 4) "create at compile time"
array1b := @{2 . 'Apple' . 2@@1 . 1/3 @} "created a execution time"
array2 := Array with: 2 with: 'Apple' with: 2@@3 with: 1/3.
array3 := Array ofSize: 4 "an empty array with a 4 elements capacity"}

Array @smalltalk{array1} and @smalltalk{array1b} are bit
different. The former one is created and filled with its contents at
compile time of the code, the consequence is it can only be filled
with literal elements as integer, float, string. The later one is
created at execution time of the code, it can be filled with elements
instantiated at the execution time as @class{Fraction} or
@class{Point} instances.

@cindex collection, access element
You can access element:
@smalltalkExampleCaption{Collection access to elements,collectionAccess,
array1 first @result{} 2
array1 second @result{} 'Apple'
array1 third @result{} $@@
array1 fourth @result{} 4
array1 last @result{} 4
array1 at: 2 @result{} 'Apple'
array2 at: 3 @result{} $2@@3
array2 swap: 2 with: 4 @result{} #(2 4 $@@ 'Apple') 
array1 at: 2 put: 'Orange'; yourself @result{} #(2 'Orange' $@@ 4)
array1 indexOf: 'Apple' @result{} 2}

Use the system browser to discover alternative way to access elements
of a collection.

@exercise{Access part of a collection, collFirst, @emph{What is the
appropriate message to access the first 2 elements of the
@smalltalk{array1} collection?}}

You can't add or remove an element, though:

@smalltalkExample{array1 add: 'Orange'
@result{} Error: 'This message is not appropriate for this object'
array1 remove: 'Apple'
@result{}  Error: 'This message is not appropriate for this object'}

Nevertheless, it is possible to fill at once an array:

@exercise{Fill an array,fillArray, @emph{How will you fill at once
@smalltalk{array4} with 'kiwi'?}}

@cindex collection, variable size
@strong{Collection of variable size.}  Such collection are gathered in
several class categories: @option{Collections-Unordered},
@option{Collections-Sequenceable}, etc. They represent the most common
collections.

@class{OrderedCollection} is a notable one. Its elements are ordered:
elements are added one after the other one@footnote{Of course you can
insert an element between two elements. However @class{LinkList}
instance are more efficient for this use case scenario.}. Its size is
variable depending on added or removed elements.

@cindex collection, instantiate variable size array
@cindex @class{OrderedCollection}

@smalltalkExampleCaption{Collection with a variable size, createOrderedColl,
coll1 := @{2 . 'Apple' . 2@@1 . 1/3 @} asOrdredCollection
coll2 := OrderedCollection with: 2 with: 'Apple' with: 2@@1 with: 1/3
coll3 := OrderedCollection ofSize: 4}

The access to its elements is identical to an @class{Array}
instance. You can add and remove element, though:

@smalltalkExampleCaption{Adding@comma{} removing element from a
dynamic array,remDelArray,
coll1 add: 'Orange'; yourself
@result{} an OrderedCollection(2 'Apple' 2@@1 1/3 'Orange')
coll1 remove: 2@@1; yourself
@result{} an OrderedCollection(2 'Apple' 1/3)} 

@c exercise with ordered collection
@exercise{Add an element after,addAfter, @emph{How to add 'Orange' after
'Apple' in @smalltalk{coll1}?}}

@c Explain in detail Dictionary and Set
@cindex @class{Set}
@cindex collection, @class{Set}
@strong{Set.} @class{Set} is an unordered collection without duplicated
elements. The order of the element is not guaranteed, though. Observe
how pi is the first element of the set:

@smalltalkExampleCaption{Set collection, setCollection,
set := Set new.
set add: 1; add: Float pi; yourself
@result{} a Set(3.141592653589793 1)}

Non duplicate are guaranteed at best, even with number of different
types. Observe how @smalltalk{1}, @smalltalk{3/3} and @smalltalk{1.0}
are considered equal and not duplicated in the set:

@smalltalkExampleCaption{Set@comma{} without duplicates, setWithoutDuplicates,
set := Set new.
set add: 1; add: Float pi; add: 3/3; add: 1/3; add: 1.0; yourself
@result{} a Set(1/3 3.141592653589793 1)}


@cindex collection, convert
A very handy way to create a @class{Set} instance, or any other
collection, is to create a dynamic array and convert it with the
@msg{asSet} message:

@smalltalkExampleCaption{Convert dynamic array, convertDynArray,
@{1 . Float pi . 3/3 . 1/3 . 1.0@} asSet
@result{} a Set(3.141592653589793 1/3 1)}

Observe the alternate conversion messages:

@smalltalkExample{@{1 . Float pi . 3/3 . 1/3 . 1.0@} asOrderedCollection
@result{} an OrderedCollection(1 3.141592653589793 1 1/3 1.0) 

@{1 . Float pi . 3/3 . 1/3 . 1.0@} asSortedCollection
@result{} a SortedCollection(1/3 1 1 1.0 3.141592653589793)}

To compile the divisors list of 30 and 45 (not the common divisors):

@smalltalkExample{Set  new 
   addAll: #(1 2 3 5 6 10 15 30) ; 
   addAll: #(1 3 5 9 15 45) ; 
   yourself. 
@result{} a Set(5 10 15 1 6 30 45 2 3 9) }

@exercise{Letters, setLetters, @emph{How will you compile the letters in
the sentences 'buenos d@'{@dotless{i}}as' and 'bonjour'?}}

@cindex collection, @class{Dictionary}
@cindex @class{Dictionary}
@strong{Dictionary.} A dictionary is a list of associations between a
key and an object. Of course a key is an object, but it must respond
to the equality behavior. Most of the time, the used are symbol.

To compile a list of colors:

@smalltalkExampleCaption{Dictionary of colors, colorDict,
| colors |
colors := Dictonary new.
colors
   add: #red -> Color red;
   add: #blue -> Color blue;
   add: #green -> Color green}

There are shorter writings:
@smalltalkExample{colors := Dictionary newFrom:
   @{#red -> Color red . #blue -> Color blue . #green -> Color green@}.
colors := @{#red -> Color red . #blue -> Color blue .
   #green -> Color green@} asDictionary}

You access color by symbols:

@smalltalkExample{colors at: #blue
@result{} Color blue
colors at: #blue put: Color blue darker
colors at: #yellow ifAbsentPut: Color yellow
@result{} association `#yellow -> Colors yellow` added to the dictionary}


There are different way to access a dictionary contents:

@smalltalkExample{colors keys.
@result{} #(#red #green #blue) 
colors keyAtValue: Color green
@result{} #green }

@strong{Beware.} The classic enumerators iterate the values of the
dictionary:

@smalltalkExample{colors do: [:value | Transcript show:  value; space ]
@result{} (Color r: 1.000 g: 1.000 b: 0.078) (Color r: 0.898 g: 0.000 b: 0.000)...}

Sometimes, you really need to iterated the whole key-value association:

@smalltalkExample{colors associationsDo: [:assoc | 
   Transcript show: assoc key; space; assoc value; cr ] }

There are other variants to explore by yourself.

@exercise{Color by name, nameColor, @emph{With an appropriate
enumerator, how will you edit the contents of the @smalltalk{colors}
dictionary to replace its values with a nicely capitalized string?}}

@c The other kind of collection should be self-discoverable
There are many more collections to explore. You now know enough to
explore and to search by yourself with the system browser, and to
experiment with the workspace.
