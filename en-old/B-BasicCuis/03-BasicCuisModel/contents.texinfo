@node @cuis{} syntax
@chapter @cuis{} syntax

@menu
* Syntactic elements::
* Pseudo-variables::
* Message sends::
* Method syntax::
* Block syntax::
* Control flow with block and message::
@end menu


@cuis{} syntax is minimal. Essentially there is syntax only for
sending messages (i.e., expressions) . Expressions are built up from a
very small number of primitive elements. There are only 6 keywords,
and @strong{there is no syntax for control structures} or declaring
new classes. Instead, nearly everything is achieved by sending
messages to objects. For instance, instead of an if-then-else control
structure, Smalltalk sends messages like @msg{ifTrue:} to
@class{Boolean} objects. New (sub-)classes are created by sending a
message to their superclass.

@node Syntactic elements
@section Syntactic elements
Expressions are composed of the following building blocks:

@enumerate

  @item six reserved keywords, or @emph{pseudo-variables}:
    @smalltalk{self}, @smalltalk{super}, @smalltalk{nil},
    @smalltalk{true}, @smalltalk{false}, and @smalltalk{thisContext},

  @item constant expressions for @emph{literal objects} including
  numbers, characters, strings, symbols and arrays,

  @item variable declarations

  @item assignments,

  @item block closures,
  
  @item messages.

@end enumerate

Observe the various syntactic elements in @ref{cuisSyntax}.

@float @emph{Table},cuisSyntax
@multitable @columnfractions .45 .55
@headitem TableSyntax @tab What it represents
   @item @smalltalk{startPoint}                 @tab a variable name
   @item @smalltalk{Transcript}                 @tab a global variable name
   @item @smalltalk{self}                       @tab pseudo-variable
   @item @tab
   @item @smalltalk{1}                          @tab decimal integer
   @item @smalltalk{2r101}                      @tab binary integer
   @item @smalltalk{1.5}                        @tab floating point number
   @item @smalltalk{2.4e7}                      @tab exponential notation
   @item @smalltalk{$a}                         @tab the character ‘a’
   @item @smalltalk{'Hello'}                     @tab the string “Hello”
   @item @smalltalk{#Hello}                     @tab the symbol #Hello
   @item @smalltalk{#(1 2 3)}                   @tab a literal array
   @item @smalltalk{@{1. 2. 1 + 2@}}              @tab a dynamic array
   @item @tab
   @item @smalltalk{"a comment"}                @tab a comment
   @item @tab
   @item @smalltalk{|xy|}                       @tab declaration of variables x and y
   @item @smalltalk{x := 1}                     @tab assign 1 to x
   @item @smalltalk{[x + y]}                      @tab a block that evaluates to x+y
   @item @smalltalk{<primitive: 1>}             @tab virtual machine primitive or annotation
   @item @tab
   @item @smalltalk{3 factorial}                @tab unary message
   @item @smalltalk{3+4}                        @tab binary messages
   @item @smalltalk{2 raisedTo: 6 modulo: 10}   @tab keyword message
   @item @tab
   @item @smalltalk{^ true}                     @tab return the value true
   @item @smalltalk{Transcript show: ’hello’. Transcript cr} @tab expression separator (.)
   @item @smalltalk{Transcript show: ’hello’; cr} @tab message cascade (;)
@end multitable
@caption {@cuis{} syntax}
@end float


@table @strong
 @cindex local variable
 @item Local variables.

 @smalltalk{startPoint} is a variable name, or identifier. By
 convention, identifiers are composed of words in “camelCase” (i.e.,
 each word except the first starting with an upper case letter). The
 first letter of an instance variable, method or block argument, or
 temporary variable must be lower case. This indicates to the reader
 that the variable has a private scope.

 @cindex shared variable
 @item Shared variables

 Identifiers that start with upper case letters are global variables,
 class variables, pool dictionaries or class
 names. @smalltalk{Smalltalk} is a global variable, an instance of the
 class @class{SystemDictionary}.

 @cindex receiver
 @item The receiver.

 @smalltalk{self} is a keyword that refers to the object inside which
 the current method is executing. We call it “the receiver” because
 this object will normally have received the message that caused the
 method to execute. self is called a “pseudo-variable” since we cannot
 assign to it.

 @cindex integer
 @cindex number, integer
 @item Integers.

 In addition to ordinary decimal integers like @smalltalk{42}, @cuis{}
 also provides a radix notation. @smalltalk{2r101} is 101 in radix 2
 (i.e., binary), which is equal to decimal 5.

 @cindex float
 @cindex number, float
 @item Float point numbers.

 Floating point numbers can be specified with their base-ten exponent:
 @smalltalk{2.4e7} is 2.4 × 10@sup{7}.

 @cindex character
 @item Characters.

 A dollar sign introduces a literal character: @smalltalk{$a} is the
 literal for ‘a’. Instances of non-printing characters can be obtained
 by sending appropriately named messages to the @class{Character}
 class, such as @smalltalk{Character space} and @smalltalk{Character
 tab}.

 @cindex string
 @item Strings.

 Single quotes are used to define a literal string. If you want a
 string with a quote inside, just double the quote, as in
 @smalltalk{'G''day'}.

 @cindex symbol
 @item Symbols.

 Symbols are like Strings, in that they contain a sequence of
 characters.  However, unlike a string, a literal symbol is guaranteed
 to be globally unique. There is only one Symbol object
 @smalltalk{#Hello} but there may be multiple String objects with the
 value @smalltalk{'Hello'}.

 @cindex array, static
 @item Static arrays.

 Static arrays or Compile-time arrays are defined by @smalltalk{#( )},
 surrounding space-separated literals. Everything within the
 parentheses must be a compile-time constant. For example,
 @smalltalk{#(27 #(true false) abc)} is a literal array of three
 elements: the integer @smalltalk{27}, the compile-time array containing the two
 booleans, and the symbol @smalltalk{#abc}.

 @cindex array, dynamic
 @item Dynamic arrays.

 Dynamic arrays or Run-time arrays. Curly braces @{ @} define a
 (dynamic) array at run-time.  Elements are expressions separated by
 periods. So @smalltalk{@{ 1. 2. 1+2 @}} defines an array with
 elements @smalltalk{1}, @smalltalk{2}, and the result of evaluating
 @smalltalk{1+2}. (The curly-brace notation is peculiar to the Squeak
 family dialect of Smalltalk! In other Smalltalks you must build up
 dynamic arrays explicitly.)

 @cindex comment
 @item Comments.

 Comments are enclosed in double quotes. @smalltalk{"hello"} is a
 comment, not a string, and is ignored by the @cuis{}
 compiler. Comments may span multiple lines.

 @cindex local variable, declaration
 @item Local variable declarations.

 Vertical bars | | enclose the declaration of one or more local
 variables in a method (and also in a block).

 @cindex assignment
 @item Assignment.

 @smalltalk{:=} assigns an object to a variable. Sometimes you will
 see @assign{} used instead. Since this character is not present in the
 keyboard, you key in with the underscore character key. So,
 @smalltalk{x := 1} is the same as @smalltalk{x @assign{} 1} or
 @smalltalk{x _ 1}.

 @cindex block
 @item Blocks.

 Square brackets @smalltalk{[ ]} define a block, also known as a block
 closure or a lexical closure, which is a first-class object
 representing a function. As we shall see, blocks may take arguments
 and can have local variables.

 @cindex primitive
 @item Primitives.

 @smalltalk{<primitive: ...>} denotes an invocation of a virtual
 machine primitive. (@smalltalk{<primitive: 1>} is the VM primitive
 for @smalltalk{SmallInteger>>+}.) Any code following the primitive is
 executed only if the primitive fails. The same syntax is also used
 for method annotations.

 @cindex message, unary
 @item Unary messages.

 Unary messages consist of a single word (like @msg{factorial})
 sent to a receiver (like 3).

 @cindex message, binary
 @item Binary messages.

 Binary messages are operators (like @smalltalk{+}) sent to a receiver
 and taking a single argument. In @smalltalk{3 + 4}, the receiver is
 @smalltalk{3} and the argument is @smalltalk{4}.

 @cindex message, keyword
 @item Keyword messages.

 Keyword messages consist of multiple keywords (like
 @msg{raisedTo:modulo:}), each ending with a colon and taking a single
 argument. In the expression @smalltalk{2 raisedTo: 6 modulo: 10}, the
 message selector @smalltalk{raisedTo:modulo:} takes the two arguments
 6 and 10, one following each colon. We send the message to the
 receiver 2.

 @cindex returned value
 @item Method return.

 @return{} is used to return a value from a method. (You must type ^ to obtain
 the @return{} character.)

 @cindex sequence
 @item Sequences of statements.

 A period or full-stop (.) is the statement separator.  Putting a
 period between two expressions turns them into independent
 statements.

 @cindex cascade of messages
 @item Cascades.

 Semicolons can be used to send a cascade of messages to a single
 receiver. In @smalltalk{Transcript show: 'hello'; cr} we first send
 the keyword message @msg{show: 'hello'} to the receiver
 @class{Transcript}, and then we send the unary message @msg{cr} to
 the same receiver.

@end table

@cindex variable, pseudo
@node Pseudo-variables
@section Pseudo-variables
In Smalltalk, there are 6 reserved keywords, or pseudo-variables:
@smalltalk{nil}, @smalltalk{true}, @smalltalk{false},
@smalltalk{self}, @smalltalk{super}, and @smalltalk{thisContext}. They
are called @dfn{pseudo-variables} because they are predefined and
cannot be assigned to. @smalltalk{true}, @smalltalk{false}, and
@smalltalk{nil} are constants while the values of @smalltalk{self},
@smalltalk{super}, and @smalltalk{thisContext} vary dynamically as
code is executed.

@smalltalk{true} and @smalltalk{false} are the unique instances of the
@class{Boolean} classes @class{True} and @smalltalk{False}.

@smalltalk{self} always refers to the receiver of the currently
executing method.

@smalltalk{super} also refers to the receiver of the current method,
but when you send a message to @smalltalk{super}, the method-lookup
changes so that it starts from the superclass of the class containing
the method that uses super.

@smalltalk{nil} is the undefined object. It is the unique instance of
the class @smalltalk{UndefinedObject}. Instance variables, class
variables and local variables are initialized to @smalltalk{nil}.

@smalltalk{thisContext} is a pseudo-variable that represents the top
frame of the run-time stack. In other words, it represents the
currently executing @smalltalk{MethodContext} or
@smalltalk{BlockContext}. @smalltalk{thisContext} is normally not of
interest to most programmers, but it is essential for implementing
development tools like the debugger and it is also used to implement
exception handling and continuations.

@cindex message, send
@cindex message, unary
@cindex message, binary
@cindex message, keyword
@node Message sends
@section Message sends
There are three kinds of messages in @cuis{}:

@itemize

 @item @strong{Unary messages} take no argument. @smalltalk{1
 factorial} sends the message @msg{factorial} to the object
 @smalltalk{1},

 @item @strong{Binary messages} take exactly one
 argument. @smalltalk{1 + 2} sends the message @msg{+} with argument
 @smalltalk{2} to the object @smalltalk{1}.

 @item @strong{Keyword messages} take an arbitrary number of
 arguments. @smalltalk{2 raisedTo: 6 modulo: 10} sends the message
 consisting of the message selector @msg{raisedTo:modulo:} and the
 arguments @smalltalk{6} and @smalltalk{10} to the object
 @smalltalk{2}.

@end itemize

Unary message selectors consist of alphanumeric characters, and start
with a lower case letter.

Binary message selectors consist of one or more characters from the
following set:

@smalltalkExample{+ -- / \ * ∼ < > = @@ % | & ? ,}

Keyword message selectors consist of a series of alphanumeric
keywords, where each keyword starts with a lower-case letter and ends
with a colon.

@cindex message, precedence
Unary messages have the highest precedence, then binary messages, and
finally keyword messages, so:

@smalltalkExample{2 raisedTo: 1 + 3 factorial
@result{} 128}

First we send @smalltalk{factorial} to @smalltalk{3}, then we send
@smalltalk{+ 6} to @smalltalk{1}, and finally we send
@smalltalk{raisedTo: 7} to @smalltalk{2}.

Precedence aside, evaluation is strictly from left to right, so

@smalltalkExample{1 + 2 * 3
@result{} 9}

not 7. Parentheses must be used to alter the order of evaluation:

@smalltalkExample{1 + (2 * 3)
@result{} 7}

Message sends may be composed with periods and semi-colons. A
period-separated sequence of expressions causes each expression in the
series to be evaluated as a @emph{statement}, one after the other.

@smalltalkExample{Transcript cr.
Transcript show: 'hello world'.
Transcript cr}

This will send @msg{cr} to the @class{Transcript} class, then send it
@msg{show: 'hello world'}, and finally send it another @msg{cr}.

When a series of messages is being sent to the same receiver, then this
can be expressed more succinctly as a cascade. The receiver is specified just
once, and the sequence of messages is separated by semi-colons:

@smalltalkExample{Transcript cr;
   show: 'hello world';
   cr}
   
This has precisely the same effect as the previous example.

@cindex method
@node Method syntax
@section Method syntax
Whereas expressions may be evaluated anywhere in @cuis{} (for example,
in a workspace, in a debugger, or in a browser), methods are normally
defined in a browser window, or in the debugger. (Methods can also be
filed in from an external medium, but this is not the usual way to
program in @cuis{}.)

Programs are developed one method at a time, in the context of a given
class. (A class is defined by sending a message to an existing class,
asking it to create a subclass, so there is no special syntax required
for defining classes.)

Here is the method @method{lineCount} in the class
@class{String}. (The usual convention is to refer to methods as
@smalltalk{ClassName>>methodName}, so we call this method
@smalltalk{String>>lineCount}.)

@smalltalkExampleCaption{Line count, lineCount,
String>>lineCount
  "Answer the number of lines represented by the receiver@comma{}
  where every cr adds one line."
  | cr count |
  cr := Character cr.
  count := 1 min: self size.
  self do:
     [:c | c == cr ifTrue: [count := count + 1]].
  ^ count}

Syntactically, a method consists of:

@itemize

 @item the method pattern, containing the name (@emph{i.e.},
 @method{lineCount}) and any arguments (none in this example),

 @item comments (these may occur anywhere, but the convention is to
 put one at the top that explains what the method does),
 
 @item declarations of local variables (@emph{i.e.}, @smalltalk{cr}
 and @smalltalk{count}),

 @item and any number of expressions separated by dots; here there are
 four.

@end itemize

The evaluation of any expression preceded by a @return{} (typed as ^)
will cause the method to exit at that point, returning the value of
that expression. A method that terminates without explicitly returning
some expression will implicitly return @smalltalk{self}.

Arguments and local variables should always start with lower case
letters. Names starting with upper-case letters are assumed to be
global variables. Class names, like @class{Character}, for example,
are simply global vari- ables referring to the object representing
that class.

@cindex block
@node Block syntax
@section Block syntax
Blocks provide a mechanism to defer the evaluation of expressions. A
block is essentially an anonymous function. A block is evaluated by
sending it the message value. The block answers the value of the last
expression in its body, unless there is an explicit return (with
@return{}), in which case it does not answer any value.

@smalltalkExample{[ 1 + 2 ] value
@return 3}

Blocks may take parameters, each of which is declared with a leading
colon. A vertical bar separates the parameter declaration(s) from the
body of the block. To evaluate a block with one parameter, you must
send it the message @msg{value:} with one argument. A two-parameter
block must be sent @msg{value:value:}, and so on, up to 4 arguments:

@smalltalkExample{[ :x | 1 + x ] value: 2
@result{} 3
[ :x :y | x + y ] value: 1 value: 2
@result{} 3}

If you have a block with more than four parameters, you must use
@msg{valueWithArguments:} and pass the arguments in an array. (A block
with a large number of parameters is often a sign of a design
problem.)

@cindex block, local variable
Blocks may also declare local variables, which are surrounded by
vertical bars, just like local variable declarations in a
method. Locals are declared after any arguments:

@smalltalkExample{[ :x :y | | z | z := x + y. z ] value: 1 value: 2
@result{} 3}

Blocks are actually lexical closures, since they can refer to
variables of the surrounding environment. The following block refers
to the variable x of its enclosing environment:

@smalltalkExample{|x|
x := 1.
[ :y | x + y ] value: 2
@result{} 3}

@cindex block, assigned to variable
Blocks are instances of the class @class{BlockClosure}. This means
that they are objects, so they can be assigned to variables and passed
as arguments just like any other object.

Consider the example below to compute the divisors of an integer:

@smalltalkExampleCaption{Compute divisors, computeDivisors,| n m |
n := 60.
m := 45.
(1 to: n) select: [:d | n \\ d = 0 ].
"@result{} #(1 2 3 4 5 6 10 12 15 20 30 60)"
(1 to: m) select: [:d | m \\ d = 0]
"@result{} #(1 3 5 9 15 45)"}

The problem with this example is the code duplication in the divisor
computation. We can avoid duplication with a dedicated block doing the
computation and assigning it to a variable:

@exercise{Block to compute divisors,blockDivisor, @emph{How will you
rewrite @ref{computeDivisors} to avoid code duplication?}}



@cindex control flow
@node Control flow with block and message
@section Control flow with block and message
Smalltalk offers no special syntax for control constructs. Instead,
these are typically expressed by sending messages to booleans, numbers
and collections, with blocks as arguments.

@cindex control flow, test
@cindex test
@cindex Boolean
@subheading Test
Conditionals are expressed by sending one of the messages
@msg{ifTrue:}, @msg{ifFalse:} or @msg{ifTrue:ifFalse:} to the result
of a boolean expression:

@smalltalkExample{(17 * 13 > 220)
  ifTrue: [ 'bigger' ]
  ifFalse: [ 'smaller' ]
@result{} 'bigger'}

The class @class{Boolean} offers a fascinating insight into how much
of the Smalltalk language has been pushed into the class
library. @class{Boolean} is the abstract superclass of the
@emph{Singleton} classes @class{True} and @class{False}@footnote{A
singleton class is designed to have only one instance. Each of
@class{True} and @class{False} classes has one instance,
@smalltalk{true} and @smalltalk{false}.}.

Most of the behaviour of @class{Boolean} instances can be understood
by considering the method @method{ifTrue:ifFalse:}, which takes two
blocks as arguments:

@smalltalkExample{(4 factorial > 20) ifTrue: [ 'bigger' ] ifFalse: [ 'smaller' ]
@result{} 'bigger'}

The method is abstract in @class{Boolean}. It is implemented in its
concrete subclasses @class{True} and @class{False}:

@smalltalkExampleCaption{Implementations of ifTrue:ifFalse:, ifTrueIfFalse, 
True>>ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock
  @return{} trueAlternativeBlock value

False>>ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock
  @return{} falseAlternativeBlock value}

In fact, this is the essence of OOP: when a message is sent to an
object, the object itself determines which method will be used to
respond. In this case an instance of True simply evaluates the true
alternative, while an instance of False evaluates the false
alternative. All the abstract @class{Boolean} methods are implemented
in this way for @class{True} and @class{False}. Look at another
example:

@smalltalkExampleCaption{Implementing negation, negation,
True>>not
   "Negation----answer false since the receiver is true."
   @return{} false}

Booleans offer several useful convenience methods, such as
@method{ifTrue:}, @method{ifFalse:}, @method{ifFalse:ifTrue}. You also
have the choice between eager and lazy conjunctions and disjunctions:

@smalltalkExample{(1 > 2) & (3 < 4)
@result{} false  "must evaluate both sides"
(1 > 2) and: [ 3 < 4 ]
@result{} false   "only evaluate receiver"
(1 > 2) and: [ (1 / 0) > 0 ]
@result{} false "argument block is never evaluated, so no exception"}

In the first example, both @class{Boolean} subexpressions are
evaluated, since @smalltalk{&} takes a @class{Boolean} argument. In
the second and third examples, only the first is evaluated, since
@method{and:} expects a @class{Block} as its argument. The
@class{Block} is evaluated only if the first argument is true.

@exercise{Implementing @method{and:} and @method{or:}, implementingAndOr,
@emph{Try to imagine how @method{and:} and @method{or:} are  implemented.}}

@cindex control flow, loop
@cindex loop
@subheading Loop
Loops are typically expressed by sending messages to blocks, integers
or collections. Since the exit condition for a loop may be repeatedly
evaluated, it should be a block rather than a boolean value. Here is
an example of a very procedural loop:

@smalltalkExample{n := 1.
[ n < 1000 ] whileTrue: [ n := n * 2 ].
n @result{} 1024}

@msg{whileFalse:} reverses the exit condition:

@smalltalkExample{n := 1.
[ n > 1000 ] whileFalse: [ n := n * 2 ].
n @result{} 1024}

You can check all the alternatives in the @option{controlling} method
category of the class @class{BlockClosure}.

@msg{timesRepeat:} offers a simple way to implement a fixed iteration:

@smalltalkExample{n := 1.
10 timesRepeat: [ n := n * 2 ].
n @result{} 1024}

We can also send the message @msg{to:do:} to a number which then acts
as the initial value of a loop counter. The two arguments are the
upper bound, and a block that takes the current value of the loop
counter as its argument:

@smalltalkExample{result := String new.
1 to: 10 do: [:n | result := result, n printString, ' '].
result @result{} '1 2 3 4 5 6 7 8 9 10 '}

You can check all the alternatives in the @option{intervals} method
category of the class @class{Number}.
