@c Solution of the exercises
@node Solutions of the Exercises
@appendix Solutions of the Exercises


@menu
* Smallltalk Philosophy (Solutions)::
* The Message Way of Life (Solutions)::
* Class -- model of Communicating Entities (Solutions)::
* The Collection Way of Life (Solutions)::
* Control Flow Messaging (Solutions)::
* Visual with Morph (Solutions)::
* Events (Solutions)::
@end menu

@c Chapter 1
@node Smallltalk Philosophy (Solutions)
@unnumberedsec Smallltalk Philosophy
@subheading @ref{exePlacement}
@figure{Placement,E-img1,8}

@subheading @ref{concatenateCapitalize}
@example
Transcript show: 'Hello ', 'my beloved ' capitalized, 'friend'
@end example


@subheading @ref{inverseSum}
@example
1 + (1/2) + (1/3) + (1/4)
@result{} 25/12 
@end example

@subheading @ref{capWordNumber}
Several messages can be sent one after the other:
@example
Transcript show: 2020 printStringWords capitalized 
@end example

@c Chapter 2
@node The Message Way of Life (Solutions)
@unnumberedsec The Message Way of Life
@subheading @ref{helloBelle}
@example
'Hello' 
   at: 1 put: $B;
   at: 2 put: $e;
   at: 3 put: $l;
   at: 4 put: $l;
   at: 5 put: $e;
   yourself
@end example

@subheading @ref{squaredSum}
@example
1 + (1/2) squared + (1/3) squared + (1/4) squared
@result{}  205 / 144
@end example

@subheading @ref{stringArith}
From a System Browser, do from the left panel to the
right ...@clicksequence{@option{Kernel-Text} @click{} @class{String}
@click{} @smalltalk{arithmetic}}... the count of methods in the last
right panel is 6: @method{*}, @method{+}, @method{-}, @method{/},
@method{//} and @method{\\}.

@c Chapter 3
@node Class -- model of Communicating Entities (Solutions)
@unnumberedsec Class, model of Communicating Entities
@subheading @ref{floatInfo}
When the @class{Float} is selected, the wide text pane prints: ``class
definition for Float @textdegree{} 92 instance methods @textdegree{}
34 class methods @textdegree{} 1280 total lines of code''

@subheading @ref{cosTable}
@example
0 to: Float twoPi by: 1/10 do: [:i |
   Transcript show: i cos; cr]
@end example

@subheading @ref{multiplyBy1024}
1024 is not a random number. It is 2@sup{10} then written in base 2 :
10000000000, it is also @smalltalk{1 << 10}:

@example
2^10 @result{} 1024
1024 printStringBase: 2 @result{} '10000000000'
1 << 10 @result{} 1024 
@end example

Therefore, to multiply an integer by 1024, we shift left of 10 its digits:

@example
360 << 10 @result{} 368640 
360 * 1024 @result{} 368640 
@end example

@subheading @ref{exeFloatPrecision}
@example
5.2 + 0.9  - 6.1
@result{} 8.881784197001252e-16

5.2 + 0.7 + 0.11
@result{} 6.010000000000001

1.2 * 3  - 3.6
@result{} -4.440892098500626e-16
@end example

@subheading @ref{exeZeroDivide}
The system returns the error @smalltalk{ZeroDivide}, division by zero.

@subheading @ref{exeFractionPrecision}
@example
(52/10) + (9/10)  - (61/10)
@result{} 0

(52/10) + (7/10)  + (11/100)
@result{} 601/100 soit 6.01

(12/10) * 3  - (36/10)
@result{} 0
@end example

@subheading @ref{selectApples}
There are different options, with slightly different results:
@example
'There are 12 apples' select: [:i |i isLetter].
@result{} 'Thereareapples' 
@end example

Not really satisfying. So another option:
@example
'There are 12 apples' select: [:i |i isDigit not].
@result{} 'There are  apples'
@end example

Or even a shorter option with the @msg{reject:} message:
@example
'There are 12 apples' reject: [:i |i isDigit].
@result{} 'There are  apples' 
@end example

@subheading @ref{formatString}
In @class{String}, search for the method category @option{format}, there
you find the @method{format:} method:
@example
'Joe bought @{1@} apples and @{2@} oranges' format: #(5 4)
@result{}  'Joe bought 5 apples and 4 oranges' 
@end example



@subheading @ref{spacewarVar}
The @class{SpaceWar}, @class{CentralStar} and @class{SpaceShip}
definitions with their added instance variable should look like:
@example
Object subclass: #SpaceWar
   instanceVariableNames: 'centralStar ships torpedoes'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'

Object subclass: #CentralStar
   instanceVariableNames: 'mass'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'

Object subclass: #SpaceShip
   instanceVariableNames: 'name position heading velocity
      fuel torpedoes mass acceleration'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'
@end example

@subheading @ref{spaceShipGetters}
@example
SpaceShip>>position
   ^ position

SpaceShip>>velocity
   ^ position

SpaceShip>>mass
   ^ mass
@end example

@subheading @ref{spaceShipSetters}
@example
SpaceShip>>position: aPoint
   position @assign{} aPoint

SpaceShip>>velocity: aPoint
   velocity @assign{} aPoint
@end example

@subheading @ref{shipHeading}
@example
SpaceShip>>left
"Rotate the ship to its left"
   heading @assign{} heading + 0.1

SpaceShip>>right
"Rotate the ship to its right"
   heading @assign{} heading - 0.1
@end example

@subheading @ref{shipAcceleration}
@example
SpaceShip>>push
"Init an accelaration boost"
   acceleration @assign{} 10

SpaceShip>>unpush
"Stop the accelaration boost"
   acceleration @assign{} 0
@end example


@subheading @ref{initCentralStar}
@example
CentralStar>>initialize
   super initialize.
   mass @assign{} 8000.
@end example


@c Chapter 4
@node The Collection Way of Life (Solutions)
@unnumberedsec The Collection Way of Life
@subheading @ref{cutString}
Open the protocol browser on the class @class{String}, search for the
method @method{allButFirst:} implemented in
@class{SequenceableCollection}. Read its comment in its source code.
@example
'Hello My Friend' allButFirst: 6
@result{} 'My Friend'
@end example

@subheading @ref{exeNegativeIntegers}
@example
(-80 to: 50) asArray
@end example

@subheading @ref{holeSet}
@example
(1 to: 100) difference: (25 to: 75)
@result{} #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
22 23 24 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91
92 93 94 95 96 97 98 99 100) 
@end example

@subheading @ref{oddNumbers}
@example
(-20 to: 45) select: [:z | z odd]
@end example

@subheading @ref{qtyPrime200}
@example
((101 to: 200) select: [:n | n isPrime]) size
@result{} 21 
@end example

@subheading @ref{multiples7}
@example
(1 to: 100) select:[:n | n isDivisibleBy: 7]
@result{} #(7 14 21 28 35 42 49 56 63 70 77 84 91 98) 
@end example

@subheading @ref{oddNonPrime}
This solution, based on set operations and multiple use of the
@msg{select:} message, is mostly compatible with the knowledge
acquired at this point of the book.
@example
| primeNumbers nonPrimeNumbers |
primeNumbers := (1 to: 100) select: [:n | n isPrime].
nonPrimeNumbers := (1 to: 100) difference: primeNumbers.
nonPrimeNumbers select: [:n | n odd]
@result{} #(1 9 15 21 25 27 33 35 39 45 49 51 55 57 63 65 69 75
77 81 85 87 91 93 95 99) 
@end example

A shorter solution with logical operations we have not discussed so
far:
@example
(1 to: 100) select:[:n | n isPrime not and: [n odd]]
@end example

@subheading @ref{decodeCipher}
@example
'Zpvs!bsf!cptt' collect: [:c |
   (c asciiValue - 1) asCharacter]
@result{} 'Your are a boss' 
@end example

@subheading @ref{alphabetCipher}
@example
($A to: $Z) collect: [:c |
   (c asciiValue - 65 + 3 \\ 26 + 65) asCharacter]
@end example

@subheading @ref{encodeCaesar}
In the solution of @ref{alphabetCipher}, we just need to replace the
characters intervale with a string:
@example
'SMALLTALKEXPRESSION' collect: [:c |
   (c asciiValue - 65 + 3 \\ 26 + 65) asCharacter]
@result{} 'VPDOOWDONHASUHVVLRQ' 
@end example

@subheading @ref{decodeCaesar}
@example
  'DOHDMDFWDHVW' collect: [:c |
    (c asciiValue - 65 - 3 \\ 26 + 65) asCharacter]
@result{} 'ALEAJACTAEST'
@end example

@subheading @ref{collFirst}
The appropriate message is @msg{first:}, defined in the parent
class @class{SequenceableCollection}. You need to use the protocol or
hierarchy browser on @class{Array} to discover it:

@example
array1 first: 2
@result{} #(2 'Apple') 
@end example

@subheading @ref{fillArray}
You could simply do a thumb:

@example
array4 at: 1 put: 'kiwi'.
array4 at: 2 put: 'kiwi'.
array4 at: 3 put: 'kiwi'.
array4 at: 4 put: 'kiwi'.
@end example

Or even a bit less thumb:

@example
1 to: 4 do: [:index |
   array4 at: index put: 'kiwi']
@end example

But if you search for carefully the @class{Array} protocol, you can
just do:

@example
array4 atAllPut: 'kiwi'.
@end example

@subheading @ref{addAfter}
In the @class{OrderedCollection} protocol search for the method
@method{add:after:}.
@example
coll1 := @{2 . 'Apple' . 2@@1 . 1/3 @} asOrderedCollection .		
coll1 add: 'Orange' after: 'Apple'; yourself.
@result{}  an OrderedCollection(2 'Apple' 'Orange' 2@@1 1/3) 
@end example

@subheading @ref{setLetters}
@example
Set  new
   addAll: 'buenos d@'{@dotless{i}}as';
   addAll: 'bonjour';
   yourself.
@result{}  a Set($e $j $o $a $u $b $  $@'{@dotless{i}} $r $d $n $s) 
@end example

@subheading @ref{nameColor}
@example
colors keysDo: [:key |
   colors at: key put: key asString capitalized].
colors
@result{} a Dictionary(#blue->'Blue' #green->'Green' #red->'Red'
#yellow->'Yellow' ) 
@end example

@subheading @ref{initActorsCollections}
When the game starts there is no fired torpedoes, therefore
@smalltalk{torpedoes} is an empty @class{OrderedCollection},
instantiated with the @msg{new} class message.

In the other hand, the @smalltalk{ships} is an @class{Array}
containing only two elements, the player ships. We use the
@msg{with:with} class message to instantiate and populate the array
with two ships created in the argument message.

For the readability, we split the code in several lines with the
appropriate indentation.

@example
   torpedoes @assign{} OrderedCollection new.
   ships @assign{} Array 
      with: SpaceShip new
      with: SpaceShip new.
@end example

@subheading @ref{updateShipsTorpedoes}
@example
SpaceWar>>stepAt: msSinceLast
  ships do: [:each | each update: msSinceLast / 1000 ].
  ships do: [:each | each unpush ].
  torpedoes do: [:each | each update: msSinceLast / 1000 ].
@end example



@c Chapter 5
@node Control Flow Messaging (Solutions)
@unnumberedsec Control Flow Messaging
@subheading @ref{blockDivisor}
@example
| divisors |
divisors := [:x | (1 to: x) select: [:d | x \\ d = 0] ].
divisors value: 60.
@result{} #(1 2 3 4 5 6 10 12 15 20 30 60)
divisors value: 45
@result{} #(1 3 5 9 15 45)
@end example

@subheading @ref{implementingAndOr}
Check the implementations in @class{Boolean}, @class{True} and
@class{False}.

@subheading @ref{categorizeTeleport}
Once the method is edited and saved, in the @label{Method} pane select
its name @label{teleport:} then do ...@clicksequence{right click
@click{} @label{more...} @click{} @label{change category...} @click{}
@label{events}}...

@subheading @ref{categorizeControls}
In the @label{Method} pane, select one uncategorized control method,
then do ...@clicksequence{right click @click{} @label{more...}
@click{} @label{change category} @click{} @label{new...}} key-in
@label{control}.

To categorized the remaining uncategorized control methods, repeat but
select @label{control} at the last step as this category now exists.

@subheading @ref{shipCollision}
We do not need an iterator to detect a collision between two
ships. However we use an iterator to take action on each ship when a
collision is detected.
@example
SpaceWar>>collisionsShips
| positionA position B |
   positionA @assign{} ships first morphPosition.
   positionB @assign{} ships second  morphPosition.
   (positionA dist: positionB) < 25 ifTrue: [
      ships do: [:each |
         each flashWith: Color red.
         self teleport: each]
   ]
@end example

Local variables only used to ease the code source formatting in
printed book.

@subheading @ref{torpedoSunCollision}
You just need to pick the appropriate code snippets from the
referenced exercise and examples.
@example
SpaceWar>>collisionsTorpedoesStar
| position |
   position @assign{} centralStar morphPosition.
   torpedoes do: [:each | 
      (each morphPosition dist: position) < 8 ifTrue: [
         each flashWith: Color orange.
         self destroyTorpedo: each]]
@end example


@c Chapter 6
@node Visual with Morph (Solutions)
@unnumberedsec Visual with Morph

@subheading @ref{allActorsMorph}
Just replace all @class{Object} occurrences with @class{Morph}:

@example
Morph subclass: #SpaceWar
   instanceVariableNames: 'centralStar ships torpedoes'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'

Morph subclass: #CentralStar
   instanceVariableNames: 'mass'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'

Morph subclass: #SpaceShip
   instanceVariableNames: 'name position heading velocity
      fuel torpedoes mass acceleration'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'
@end example


@subheading @ref{refactoryShipTorpedo}

@example
Mobile subclass: #SpaceShip
   instanceVariableNames: 'name heading fuel torpedoes'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'

Mobile subclass: #Torpedo
   instanceVariableNames: 'lifeSpan'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'
@end example



@c Chapter 8
@node Events (Solutions)
@unnumberedsec Events

@subheading @ref{handleMouseOver}
The method @method{handlesMouseOver:}, implemented in the
@class{SpaceWar} morph class, returns true so the game play is
informed of mouse over events in dedicated methods.
@example
SpaceWar>>handlesMouseOver: event
   @return{} true
@end example

@subheading @ref{mouseEnter}
You need to browse the @method{Morph>>handlesMouseOver:} method and
read the comment. It writes about a @msg{mouseEnter:} message; we
implement the matching method in @class{SpaceWar} class with the
behaviors previously described:
@example
SpaceWar>>mouseEnter: event
   event hand newKeyboardFocus: self.	
   self startStepping
@end example

@subheading @ref{mouseLeave}
The message @msg{mouseLeave:} is sent to our @class{SpaceWar} instance
each time the mouse cursor move out (leaves) of the game
play. Therefore we add the homonym method to the @class{SpaceWar}
class:
@example
SpaceWar>>mouseLeave: event
   event hand releaseKeyboardFocus: self.
   self stopStepping
@end example

@subheading @ref{keyboardEvent}
The @msg{handlesKeyboard} message is sent to a morph to know if it
wants to receive keyboard event. The morph responds true to this
message to state its interest on keyboard event. We implement the
method in the @class{SpaceWar} class:
@example
SpaceWar>>handlesKeyboard
   @return{} true
@end example

@subheading @ref{secondShipControl}
We designate the characters as @smalltalk{$w $a $s $d}. We append the
code bellow to the method @method{SpaceWar>>keyStroke:}
@example
key = $w ifTrue: [@return{} ships second push].
key = $d ifTrue: [@return{} ships second right].
key = $a ifTrue: [@return{} ships second left].
key = $s ifTrue: [@return{} ships second fireTorpedo]
@end example
