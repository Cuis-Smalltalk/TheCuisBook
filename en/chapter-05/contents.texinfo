@node Control Flow Messaging
@chapter Control Flow Messaging

@cuis{} syntax is minimal. Essentially there is syntax only for
sending messages (i.e., expressions) . Expressions are built up from a
very small number of primitive elements. There are only 6 keywords,
and @strong{there is no syntax for control structures} or declaring
new classes. Instead, nearly everything is achieved by sending
messages to objects. For instance, instead of an if-then-else control
structure, Smalltalk sends messages like @msg{ifTrue:} to
@class{Boolean} objects. As we already know, new (sub-)classes are
created by sending a message to their superclass.

@menu
* Syntactic elements::
* Pseudo-variables::
* Method syntax::
* Block syntax::
* Control flow with block and message::
@end menu

@node Syntactic elements
@section Syntactic elements
Expressions are composed of the following building blocks:

@enumerate

  @item six reserved keywords, or @emph{pseudo-variables}:
    @smalltalk{self}, @smalltalk{super}, @smalltalk{nil},
    @smalltalk{true}, @smalltalk{false}, and @smalltalk{thisContext},

  @item constant expressions for @emph{literal objects} including
  numbers, characters, strings, symbols and arrays,

  @item variable declarations

  @item assignments,

  @item block closures,
  
  @item messages.

@end enumerate

@cindex pseudo-variable
@node Pseudo-variables
@section Pseudo-variables
In Smalltalk, there are 6 reserved keywords, or pseudo-variables:

@indentedblock
@smalltalk{nil}, @smalltalk{true}, @smalltalk{false},
@smalltalk{self}, @smalltalk{super}, and @smalltalk{thisContext}.
@end indentedblock


They are called @dfn{pseudo-variables} because they are predefined and
cannot be assigned to. @smalltalk{true}, @smalltalk{false}, and
@smalltalk{nil} are constants while the values of @smalltalk{self},
@smalltalk{super}, and @smalltalk{thisContext} vary dynamically as
code is executed.


@itemize

   @item @smalltalk{true} and @smalltalk{false} are the unique
   instances of the @class{Boolean} classes @class{True} and
   @smalltalk{False}.
   
   @item @smalltalk{self} always refers to the receiver of the
   currently executing method.
   
   @item @smalltalk{super} also refers to the receiver of the current
   method, but when you send a message to @smalltalk{super}, the
   method-lookup changes so that it starts from the superclass of the
   class containing the method that uses super.
   
   @item @smalltalk{nil} is the undefined object. It is the unique
   instance of the class @smalltalk{UndefinedObject}. Instance
   variables, class variables and local variables are initialized to
   @smalltalk{nil}.
   
   @item @smalltalk{thisContext} is a pseudo-variable that represents
   the top frame of the run-time stack. In other words, it represents
   the currently executing @smalltalk{MethodContext} or
   @smalltalk{BlockContext}. @smalltalk{thisContext} is normally not
   of interest to most programmers, but it is essential for
   implementing development tools like the debugger and it is also
   used to implement exception handling and continuations.

@end itemize

@cindex method
@node Method syntax
@section Method syntax
Whereas expressions may be evaluated anywhere in @cuis{} (for example,
in a workspace, in a debugger, or in a browser), methods are normally
defined in a browser window, or in the debugger. (Methods can also be
filed in from an external medium, but this is not the usual way to
program in @cuis{}.)

Programs are developed one method at a time, in the context of a given
class. (A class is defined by sending a message to an existing class,
asking it to create a subclass, so there is no special syntax required
for defining classes.)

Here is the method @method{lineCount} in the class
@class{String}. (The usual convention is to refer to methods as
@smalltalk{ClassName>>methodName}, so we call this method
@smalltalk{String>>lineCount}.)

@smalltalkExampleCaption{Line count, lineCount,
String>>lineCount
  "Answer the number of lines represented by the receiver@comma{}
  where every cr adds one line."
  | cr count |
  cr := Character cr.
  count := 1 min: self size.
  self do:
     [:c | c == cr ifTrue: [count := count + 1]].
  ^ count}

Syntactically, a method consists of:

@itemize

 @item the method pattern, containing the name (@emph{i.e.},
 @method{lineCount}) and any arguments (none in this example),

 @item comments (these may occur anywhere, but the convention is to
 put one at the top that explains what the method does),
 
 @item declarations of local variables (@emph{i.e.}, @smalltalk{cr}
 and @smalltalk{count}),

 @item and any number of expressions separated by dots; here there are
 four.

@end itemize

The evaluation of any expression preceded by a @return{} (typed as ^)
will cause the method to exit at that point, returning the value of
that expression. A method that terminates without explicitly returning
some expression will implicitly return @smalltalk{self}.

Arguments and local variables should always start with lower case
letters. Names starting with upper-case letters are assumed to be
global variables. Class names, like @class{Character}, for example,
are simply global vari- ables referring to the object representing
that class.

@cindex block
@node Block syntax
@section Block syntax
Blocks provide a mechanism to defer the evaluation of expressions. A
block is essentially an anonymous function. A block is evaluated by
sending it the message value. The block answers the value of the last
expression in its body, unless there is an explicit return (with
@return{}), in which case it does not answer any value.

@smalltalkExample{[ 1 + 2 ] value
@return 3}

Blocks may take parameters, each of which is declared with a leading
colon. A vertical bar separates the parameter declaration(s) from the
body of the block. To evaluate a block with one parameter, you must
send it the message @msg{value:} with one argument. A two-parameter
block must be sent @msg{value:value:}, and so on, up to 4 arguments:

@smalltalkExample{[ :x | 1 + x ] value: 2
@result{} 3
[ :x :y | x + y ] value: 1 value: 2
@result{} 3}

If you have a block with more than four parameters, you must use
@msg{valueWithArguments:} and pass the arguments in an array. (A block
with a large number of parameters is often a sign of a design
problem.)

@cindex block, local variable
Blocks may also declare local variables, which are surrounded by
vertical bars, just like local variable declarations in a
method. Locals are declared after any arguments:

@smalltalkExample{[ :x :y | | z | z := x + y. z ] value: 1 value: 2
@result{} 3}

Blocks are actually lexical closures, since they can refer to
variables of the surrounding environment. The following block refers
to the variable x of its enclosing environment:

@smalltalkExample{|x|
x := 1.
[ :y | x + y ] value: 2
@result{} 3}

@cindex block, assigned to a variable
Blocks are instances of the class @class{BlockClosure}. This means
that they are objects, so they can be assigned to variables and passed
as arguments just like any other object.

Consider the example below to compute the divisors of an integer:

@smalltalkExampleCaption{Compute divisors, computeDivisors,| n m |
n := 60.
m := 45.
(1 to: n) select: [:d | n \\ d = 0 ].
"@result{} #(1 2 3 4 5 6 10 12 15 20 30 60)"
(1 to: m) select: [:d | m \\ d = 0]
"@result{} #(1 3 5 9 15 45)"}

The problem with this example is the code duplication in the divisor
computation. We can avoid duplication with a dedicated block doing the
computation and assigning it to a variable:

@exercise{Block to compute divisors,blockDivisor, @emph{How will you
rewrite @ref{computeDivisors} to avoid code duplication?}}



@cindex control flow
@node Control flow with block and message
@section Control flow with block and message
Smalltalk offers no special syntax for control constructs. Instead,
these are typically expressed by sending messages to booleans, numbers
and collections, with blocks as arguments.

@cindex control flow, test
@cindex test
@cindex Boolean
@subheading Test
Conditionals are expressed by sending one of the messages
@msg{ifTrue:}, @msg{ifFalse:} or @msg{ifTrue:ifFalse:} to the result
of a boolean expression:

@smalltalkExample{(17 * 13 > 220)
  ifTrue: [ 'bigger' ]
  ifFalse: [ 'smaller' ]
@result{} 'bigger'}

The class @class{Boolean} offers a fascinating insight into how much
of the Smalltalk language has been pushed into the class
library. @class{Boolean} is the abstract superclass of the
@emph{Singleton} classes @class{True} and @class{False}@footnote{A
singleton class is designed to have only one instance. Each of
@class{True} and @class{False} classes has one instance,
@smalltalk{true} and @smalltalk{false}.}.

Most of the behaviour of @class{Boolean} instances can be understood
by considering the method @method{ifTrue:ifFalse:}, which takes two
blocks as arguments:

@smalltalkExample{(4 factorial > 20) ifTrue: [ 'bigger' ] ifFalse: [ 'smaller' ]
@result{} 'bigger'}

The method is abstract in @class{Boolean}. It is implemented in its
concrete subclasses @class{True} and @class{False}:

@smalltalkExampleCaption{Implementations of ifTrue:ifFalse:, ifTrueIfFalse, 
True>>ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock
  @return{} trueAlternativeBlock value

False>>ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock
  @return{} falseAlternativeBlock value}

In fact, this is the essence of OOP: when a message is sent to an
object, the object itself determines which method will be used to
respond. In this case an instance of True simply evaluates the true
alternative, while an instance of False evaluates the false
alternative. All the abstract @class{Boolean} methods are implemented
in this way for @class{True} and @class{False}. Look at another
example:

@smalltalkExampleCaption{Implementing negation, negation,
True>>not
   "Negation----answer false since the receiver is true."
   @return{} false}

Booleans offer several useful convenience methods, such as
@method{ifTrue:}, @method{ifFalse:}, @method{ifFalse:ifTrue}. You also
have the choice between eager and lazy conjunctions and disjunctions:

@smalltalkExample{(1 > 2) & (3 < 4)
@result{} false  "must evaluate both sides"
(1 > 2) and: [ 3 < 4 ]
@result{} false   "only evaluate receiver"
(1 > 2) and: [ (1 / 0) > 0 ]
@result{} false "argument block is never evaluated, so no exception"}

In the first example, both @class{Boolean} subexpressions are
evaluated, since @smalltalk{&} takes a @class{Boolean} argument. In
the second and third examples, only the first is evaluated, since
@method{and:} expects a @class{Block} as its argument. The
@class{Block} is evaluated only if the first argument is true.

@exercise{Implementing @method{and:} and @method{or:}, implementingAndOr,
@emph{Try to imagine how @method{and:} and @method{or:} are  implemented.}}

@cindex control flow, loop
@cindex loop
@subheading Loop
Loops are typically expressed by sending messages to blocks, integers
or collections. Since the exit condition for a loop may be repeatedly
evaluated, it should be a block rather than a boolean value. Here is
an example of a very procedural loop:

@smalltalkExample{n := 1.
[ n < 1000 ] whileTrue: [ n := n * 2 ].
n @result{} 1024}

@msg{whileFalse:} reverses the exit condition:

@smalltalkExample{n := 1.
[ n > 1000 ] whileFalse: [ n := n * 2 ].
n @result{} 1024}

You can check all the alternatives in the @label{controlling} method
category of the class @class{BlockClosure}.

@msg{timesRepeat:} offers a simple way to implement a fixed iteration:

@smalltalkExample{n := 1.
10 timesRepeat: [ n := n * 2 ].
n @result{} 1024}

We can also send the message @msg{to:do:} to a number which then acts
as the initial value of a loop counter. The two arguments are the
upper bound, and a block that takes the current value of the loop
counter as its argument:

@smalltalkExample{result := String new.
1 to: 10 do: [:n | result := result, n printString, ' '].
result @result{} '1 2 3 4 5 6 7 8 9 10 '}

You can check all the alternatives in the @label{intervals} method
category of the class @class{Number}.
