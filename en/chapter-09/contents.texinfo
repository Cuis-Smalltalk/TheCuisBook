@node Code Management
@chapter Code Management

Regarding the source code, @cuis{} comes with several tools to
manipulate it: the image, the change record, the change set and the
package system. We give you a tour around these mechanisms then explain
how you should manage the code of an application written with @cuis{}.

@menu
* The Image::
* The Change Log::
* The Change Set::
* The Package::
* Daily Workflow::
@end menu

@node The Image
@section The Image

We already wrote about the @cuis{} @dfn{image} (@xref{Installing and
configuring @cuis{}}). When saving the state of the virtual machine in
the image file, every single changes done in the environment will be
included in the saved image: this includes the windows in the
environment, workspace content, newly written classes and methods,
existing instances including the visual morphs, a debugging session
with a System Browser, an inspector and a debugger.


At any time, the user can save the image with
...@clicksequence{World menu @click{}
@label{Save}}... Alternatively @label{Save as...} saves the image under
an alternate name provided by the user.

Saving the image is the easiest and straightforward method to save
your own code. But we can't really call that code management as your
code is not saved in a dedicated file of its own but along the
image. Moreover it will be unpractical to share your work with other
person.

For various reasons, an image may be in fuzzy state: the virtual
machine may crash when running it or the environment may be in a lock
down state. This is another drawback when using the image as your sole
source code repository. The net result is loosing your work.

Another situation where you lost code is a virtual machine crash or to
forget to save the image when quitting @cuis{}. In such situation
there is a solution to recover your lost editing: the @dfn{ChangeSet}.

@cindex change log
@node The Change Log
@section The Change Log

@cuis{} records any action occurring in the environment: the code you
edit in the System Browser, the code you execute in a
Workspace. Therefore, in the event of a @cuis{} crash or you did not
save your editing when quitting the environment, you can restore your
editing when starting afresh @cuis{}. Let's explore this feature with
a simple example.

On a fresh @cuis{} installation, create a new class category named
@label{TheCuisBook} and within @class{TheBook} class:

@itemize

  @item Over the class pane of System Browser (at the most left), do
   ...@clicksequence{Right click @click{} @label{add
   items... (a)}}... key in @label{TheCuisBook}.

  @item Select this new class category and create the class
  @class{TheBook} as a kind of @class{Object}: select the
  @label{TheCuisBook} category then in the source code bellow edit the
  class template to replace @smalltalk{#NameOfClass} with
  @smalltalk{#TheBook} then save the class definition with
  @kbd{Ctrl-s}.
  
@end itemize

Open a Workspace, then key in the following code:

@smalltalkExample{| myBook |
myBook @assign{} TheBook new}

@cuis{} does not save code you key in the Workspace, but code you
execute. Let's execute this code: @kbd{Ctrl-a} then @kbd{Ctrl-p}, the
Workspace prints the result: @smalltalk{a TheBook}, an instance of a
@class{TheBook} class.

Now quit @cuis{} without saving, of course it first asks us
@label{Save the current image before}, choose @label{No}, then it
warns us:

@verbatim
Some ChangeSet for Cuis core might have unsaved changes.
If you continue, they would be lost.
Continue?
@end verbatim

Proceed with @label{Yes}. At least, we are done quitting the @cuis{}
environment without saving.

Now start again @cuis{}, then do ...@clicksequence{World menu
@click{} @label{Changes...} @click{} @label{Recently logged
Changes...}}. The system presents a list image snapshpots tagged with
date stamp. Pick up the one occurring just before you lost your code.

@cindex change set
@node The Change Set
@section The Change Set

On a fresh @cuis{} installation, each code you edit in the System
Browser is recorded in a @dfn{Change Set},

You browse a change set with a tool named the @dfn{Change Sorter}:
...@clicksequence{World menu @click{} @label{Changes...}  @click{}
@label{Change Sorter}}...

@figure{The Change Sorter@comma{} class edit,ch10-ChangeSet1,8}

The @class{TheBook} class we added to @cuis{} in the previous section
is a change made to the core of the system. By default, it is recorded
in a change set automatically created by the system. In
@ref{ch10-ChangeSet1} at the top right, observe the class
@class{TheBook}, it belongs to a change set named
@label{4439-CuisCore-AuthorName-2020Nov16-13h40m}.  In the left pane,
each unsaved change set is marked with a @label{-->}. Here it tells us
the change was not saved on disk. To save the change set, just use its
contextual menu and use one of the @label{file out} entry. The change
set will be saved along the @cuis{} image under its system name with
@label{AuthorName} substituated with the real author name.

@figure{The Change Sorter@comma{} method edit,ch10-ChangeSet2,8}

Observe @ref{ch10-ChangeSet2}, after we added the method
@method{pages} to the @class{TheBook} class, the middle pane lists the
added or modified methods. When a method is selected its source code
is printed in the bottom pane.

Let's say we save the change set -- @dfn{File out} entries in the
change sorter tool menu. This creates a new file
@file{4451-CuisCore-HilaireFernandes-2020Nov14-21h08m-hlsf.001.cs.st}
along the @cuis{} image file:

@smalltalkExampleCaption{Change set contents, changeSetContents,
From Cuis 5.0 [latest update: #4450] on 18 November 2020 at 9:05:09 am'!
!classDefinition: #TheBook category: 'TheCuisBook'!
Object subclass: #TheBook
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'TheCuisBook'!

!TheBook methodsFor: 'as yet unclassified' stamp: 'hlsf 11/18/2020 09:04:58'!
pages
   @return{} 151! !}

To load this change set back in a new image, you use the @dfn{File
List} tool ...@clicksequence{World menu @click{} @label{Open} @click{}
@label{File List}}... Browse the folder containing the change set file
to load, then select it, from there you have three options to
manipulate it.

@figure{The File List tool@comma{} to install a change set and more,ch10-FileListChangeSet,11}

@itemize

  @item @label{code}. It opens a kind of System Browser limited to
  the code in the change set file. It is a very handy tool to read and
  to learn the code from the change set.

  @item @label{contents}. It opens a @dfn{Change List} tool to review
  the modifications to the image this change set will produce once
  installed. It also let you cherry pick the individual changes you
  want to install and to discard. Each line you cherry pick represents
  a class or a method addition/modification. Once you select the code
  to install, press the @label{file in selections} button to proceed
  with the installation.

  Consider a co-developer modifying the @class{TheBook} class, she
  added an instance variable @smalltalk{pages} and adjusted the
  @method{pages} methods accordingly. She filed out her changes then
  shared the file with you. Observe in @ref{ch10-ChangeList} how you
  will review her changes with the Change List tool. Stroked in red
  our code in the image to be removed and in green her changes to be
  installed.

  @figure{Change List tool to review modifications to the image,ch10-ChangeList,8}

  @item @label{install}. It just installs the complete change set
  without interactivity.
  
@end itemize

The change set way of managing the source code is used by the
developers of @cuis{}, to work on its core image. When you want to
write an application, a dedicated tool or even a set of classes
covering a specific domain, you really want to use something else to
manage the code: a package.

@node The Package
@section The Package
@cindex package
@cindex class, category
A package can hold a set of classes part of the same class category;
we already discussed it in a previous chapter, see @ref{Spacewar!
package}.

For the record, a package is defined with the class category we want
to turn as a package. Our Spacewar! game classes are part of the class
category @label{Spacewar}. To create the related package we open the
Installed Package tool, after pressing the @label{new} button we just
key in @label{Spacewar} in.

@c explain how to include class extension in a package
@cindex package, prefix
But we can do more. We can include several class categories in one
package. Consider we want to span our CuisBook classes in two
categories @label{TheCuisBook-Models} and @label{TheCuisBook-Views}, a
new package created with the name @label{TheCuisBook} include these
two class categories; this label is a @dfn{prefix} to search for the
matching categories to include in the package.

Therefore, often, a package comes with several categories to organize
the classes in matching domains. We encourage to do so. When an
application or framework grows, to keep a sound organisation, you may
fell the need to reshape the class categories: rename, split, merge,
etc. As long as you keep the same prefix in the class categories and
the package name, your classes will be safe in the same package.  For
the record, in the System Browser, you can drag and drop any class in
any class category to reorganize.

@exercise{Two class categories@comma{} one package,twoCategoriesOnePackage,
@emph{Create a @label{TheCuisBook} package from the two class
categories @label{TheCuisBook-Models} and
@label{TheCuisBook-Views}. The former contains a @class{TheBook}
class and the later a @class{TheBookMorph} class. Save the package
on disk.}}

@cindex package, system extension
Imagine we need to print the page number of the @class{TheBook} table
of contents as lower cased roman number, as we do with the printed
version of this book. The code is very simple:

@smalltalkExample{4 printStringRoman asLowercase
@result{} 'iv'}

Instead of invoking this sequence of messages each time we need it, we
 add a dedicated message to the @class{Integer} class:

@smalltalkExample{Integer>>printStringToc
   @return{} self printStringRoman asLowercase}

Now within our @class{TheBook}'s methods we just do things like:

@smalltalkExample{../..
 aPage @assign{} Page new.
 aPage number: 1 printStringToc.
 ../..}

Now we are facing a problem. For the need of the @label{TheBook}
package we extend the @class{Integer} class with a method
@method{printStringToc}, however this method addition is part of the
@cuis{} core system and its associated default change set. See
@ref{ch10-ChangeSetToCore}, the Change Sorter tool exactly shows that.

@figure{Change Sorter@comma{} supplementary method to core, ch10-ChangeSetToCore,9}

Therefore when saving our @label{TheBook} package this method is not
included and it is lost when quitting @cuis{}. To include it in our
package we categorize it in a method category with the
@label{*TheCuisBook} prefix. @label{*TheCuisBook-printing} is a good
candidate. In the System Browser method pane, over
@method{printStringToc}, do ...@clicksequence{Contextual menu @click{}
@label{more...} @click{} @label{change category...}} and key in
@label{*TheCuisBook-printing}.

Now the Change Sorter writes about @method{Integer>>printStringToc}:
@cite{Method was moved to some other package}. The Installed Packages
tools now tells us we have an extension, use its @label{browse} button
to get an update on the package contents.

@figure{Package with extension to the @class{Integer} class of the
@label{Kernel-Numbers} system class
category,ch10-BrowsePackageChange,9}

Observe how each category -- class or method one -- of an extension is
prefixed with a @label{*}.

@node Daily Workflow
@section Daily Workflow

For our Spacewar! game, we created a dedicated package
@file{Spacewar!.pck.st} file. This is the way to go when writing
external package: define a dedicated package and from time to time
save your work with the @label{save} button in the Installed Packages
tool (@xref{ch02-InstalledPackages}).

@cuis{} uses GitHub to host, version, diff its core development and to
manage a set of external packages (i.e. code that is maintained
independently and outside @cuis{} but closely related to it).

Package files are simple text files, encoded for latin alphabet (ISO
8859-15) and handled without problems by GitHub. @cuis{} uses the LF
(ascii code 10) newline convention, as preferred in GitHub. This
allows Git/GitHub to diff versions, and merge branches.

Separate GitHub repositories are used for projects, i.e. package or
set of closely related packages that are always loaded and maintained
together as a whole.

Your daily workflow with @cuis{} to develop an external package will
look like:

@enumerate

  @item Start with a standard, fresh, Cuis image. Never save the
  image.

  @item Set up your preferred version control system to manage your
  external packages. The recommendation is to use a GitHub repository
  with a name beginning with 'Cuis-Smalltalk-', so it will be easy for
  anybody to find it. But beside this consideration, using any other
  version control system is fine.
  
  @item Install the necessary packages from the @cuis{} Git
  repositories.

  @item Develop. Modify and/or create packages.

  @item Save own packages (to your preferred repositories).

  @item add / commit / push accordingly to your version control system

  @item Fileout changes that are not part of any package. These are
  automatically captured in numbered changesets, separated from
  changes to packages.

  @item Exit the image. Usually without saving.
   
@end enumerate


@todo{Requirement/dependencies}


@subsection Automate your image

As described in the daily workflow, it is a good habit to not save the
whole image but only the modified package of the edited source
code. However, each time we start a coding session, it is tedious to
set up the image to fit our personal needs and taste.

Things one may want to personalize in the image are:

@itemize

  @item The font and taskbar sizes,

  @item Placement of tools like System Browser, Workspace, Transcript,

  @item Default contents in the Workspace, ready to be executed,

  @item Installation of Packages.

@end itemize

@cindex line command option, -s (run a script)
We want to record these image preferences in a
@file{setUpEnvironment.st} script to be executed at start up. On
GNU/Linux, you ask @cuis{} to run a script with the @option{-s}, for
example @command{squeakVM Cuis5.0.image -s setUpEnvironement.st} where
@file{setUpEnvironement.st}. is a file containing Smalltalk code. A
real life example may look like:
@verbatim
../cogspur/squeak Cuis5.0-4426 -s ../scripts/setUpEnvironment.st
@end verbatim

We describe in detail an example of a set up script organizing the
environment as seen in @ref{ch10-ImageSetUp}. It is interesting
Smalltalk code poking around heterogeneous areas of @cuis{} like the
developer tools, the Morph system, the preferences and collection
handling.

@figure{Environment of an image started with the set up script,ch10-ImageSetUp,12}

@cindex morph, world
Let's start by removing the open windows:

@smalltalkExample{| list |
"Delete all windows but the taskbar"
list @assign{} UISupervisor ui submorphs reject: [:aMorph |
   aMorph is: #TaskbarMorph].
list do: [:each | each delete].}

The whole user interface world of @cuis{} is a kind of Morph, a
@class{WorldMorph} instance. Its sub morphs are windows, menus, the
taskbar or any kind of morph the user can interact with. To access
this @class{WorldMorph} instance you ask to the @class{UISupervisor}
with the @msg{ui} message. Once we select all the morphs in the world
but the taskbar -- really @msg{reject:} it -- we @msg{delete} them
from the world.

Next, we change the preferences:

@smalltalkExample{| list morph |
../..
"Change to Dark theme"
Feature require: #'Theme-Themes'.
DarkTheme beCurrent.
"Adjust font size"
Preferences smallFonts.
"Adjust taskbar size"
morph @assign{} UISupervisor ui submorphs first.
morph scale: 1 / 2.}

We require Theme-Themes package; as it is not installed on the default
image, it will be searched on the disk for installation. Regarding the
taskbar access, remember we deleted all the morphs but the taskbar
from the world, therefore the taskbar is really the first in the sub
morphs collection of the world.

Before installing the tools, we ask a @class{RealEstateAgent} the free
area. Sadly this agent does not take into consideration the area
occupied by the task bar, so we need to tweak its answer. Then we
compute a quarter of this free area extent (half in width and half
in height make a quarter of the whole free area):

@smalltalkExample{| list morph area extent |
../..
"Compute the available free space for windows placement"
area @assign{} RealEstateAgent maximumUsableArea
   extendBy: 0 @@ morph morphHeight negated.
extent @assign{} area extent // 2.}

Now we are ready to install a few tools. First three browsers each
occupying a quarter of the screen:

@smalltalkExample{"Open a few System Browsers"
BrowserWindow openBrowser
   morphBounds: (0 @@ 0 extent: extent).
BrowserWindow openBrowser
   morphBounds: (area width // 2 @@ 0 extent: extent).
"Open a System Browser on a specific class"
morph @assign{} BrowserWindow openBrowser
   morphBounds: (area extent // 2 extent: extent).
morph model setClass: Integer selector: nil.}

Then in the remaining free quarter, we install a workspace occupying
two thirds of the area and a transcript one third. The workspace is
installed with some default contents. We need to hack a bit because
when asking for a new Workspace, @cuis{} does not answer the created
instance, we have to search it in the windows of the world.

@smalltalkExample{"Open a Workspace with some default contents"
Workspace openWorkspace.
morph @assign{} UISupervisor ui submorphs detect: [:aMorph |
   aMorph class = WorkspaceWindow].
morph model actualContents: '"Some code"
1 + 2.
"Other code"
5 * 3.'.
morph morphBounds:
   (0 @@ (area height // 2)
      extent: extent x @@ (2 / 3 * extent y)).
"Open a transcript for logs"
TranscriptWindow openTranscript morphBounds: 
   (0 @@ (area height // 2 + (2 / 3 * extent y)) 
      extent: extent x @@ (1 / 3 * extent y )).}

Of course you should adjust the argument of the @msg{actualContents:}
message to meaningful code for your usage.




@c TOC
@c * Gives a few script to automate your installation
