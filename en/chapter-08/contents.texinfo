@node Events
@chapter Events

@menu
* System Events::
* Overall Mechanism::
* Spacewar! Events::
@end menu

@heading What just happened?

We talked above about control flow, how one makes decisions about what
to do in making calculations.  We talked about this like the entire
computer processing resource was dedicated to this task. But it isn't
so.

Computers may be fast at some calculations, but they are only so fast,
and when there are many things to do, one shares and takes turns.

So aside from @emph{do this and then do that}, @dfn{event}s happen.

Also, a computer may be fast enough that it literally has
@emph{nothing} to do.  What does it do then?  When a processor
@emph{goes to sleep}, how do we get its attention?

You are reading the right chapter to know.

@node System Events
@section System Events

Modern integrated @dfn{System On a Chip} (@dfn{SOC}) hardware has many
circuits which are active at the same time.  So one kind of event is
sensing something happening in the world.  Class @class{EventSensor}
handles keyboard key press and mouse @dfn{hardware interrupts},
translating between hardware signals and software event objects.

Basically, a morph @emph{raises its hand} and says what events, if
any, it is interested in receiving. Then it implements methods to get
the event objects holding the information of the captured events. In
@cuis{}, the class @class{MorphicEvent} and its subclasses represent
the diversity of events in the system.

@format
@class{MorphicEvent}
   @class{DropEvent}
   @class{DropFilesEvent}
   @class{UserInputEvent}
      @class{KeyboardEvent}
      @class{MouseEvent}
         @class{MouseButtonEvent}
         @class{MouseMoveEvent}
         @class{MouseScrollEvent}
      @class{WindowEvent}
@end format


As @class{MouseMoveEvent}s are generated, the @class{HandMorph}
adjusts its screen position.  When mouse and keystroke events arrive,
the @class{HandMorph} coordinates the ``dispatch'' of events to the
proper morph under the hand as well as displaying tool tips and
carrying morphs in transit during drag operations.

As we saw in the previous chapter with @class{ColorClickEllipse}, any
morph may override default @class{Morph} methods to assert that it
handles various user events and the methods which take the associated
event objects when events arrive.

Basically, user input events are generated, a @class{HandMorph}
reflects any cursor movement, morphs react to events, each long
running task gets a time slice and makes some progress, any display
changes are updated on the screen, and the next step happens.  Time
marches forward a step.

This happens over and over and over, keeping the juggler's illusion
that all balls in the air are moving at once.  Underneath, the balls
are each moving just a bit, in sequence.

@node Overall Mechanism
@section Overall Mechanism

@c Explain the event-handling-testing and event method categories in
@c Morph. (btw, event->event-handling,
@c event-handling->event-preferences. Need to be clarified because it
@c is confusing

@c event-handling-tested->events-handled
@c event-handling->events-preference
@c events->events-handling

In @ref{A brief introduction to Inspectors}, we explained how to
set properties for morph instance to handle specific event. In this
circumstance, one property informed @cuis{} we were interested by a
given event (@smalltalk{#handlesMouseDown}), a second property defined
the behavior with a block of code when this event occurred.

Alternatively, to handle events in a given morph class, we define the
behavior with instance methods. In the @class{Morph} class, observe
the method categories @label{event} and @label{event handling
testing}.

In @label{event handling testing} is listed methods returning a
Boolean to indicate if the instance should be notified by the
event. Let's take a look at one of these methods,
@method{handlesMouseDown:}, its comment is worth reading:

@smalltalkExample{Morph>>handlesMouseDown: aMouseButtonEvent
"Do I want to receive mouseButton messages ?
- #mouseButton1Down:localPosition:
- #mouseButton1Up:localPosition:
- #mouseButton2Down:localPosition:
- #mouseButton2Up:localPosition:
- #mouseButton3Down:localPosition:
- #mouseButton3Up:localPosition:
- #mouseMove:localPosition:
- #mouseButton2Activity
NOTE: The default response is false. Subclasses that implement these
messages directly should override this one to return true.
Implementors could query the argument, and only answer true for (for
example) button 2 up only."
"Use a property test to allow individual instances to dynamically
specify this."

   @return{} self hasProperty: #'handlesMouseDown:'}

As defined by default this method, and the other handles, checks if
there is a homonym property. In a specific morph where we want to
handle mouse down event, we just redefine it to return true:

@smalltalkExample{MyMorph>>>>handlesMouseDown: aMouseButtonEvent
   @return{} true}

Now in the @label{events} @class{Morph}'s method category, we find the
handlers listed in the comment above. A @class{ScrollBar}, a kind of
Morph to represent list scroll bar, scrolls its list contents when a
mouse button 1 is pressed:

@smalltalkExample{ScrollBar>>mouseButton1Down: aMouseBtnEvent position: eventPosition
"Update visual feedback"
   self setNextDirectionFromEvent: aMouseBtnEvent.
   self scrollByPage}

To discover other events available for your morph, proceed as
described above.

@node Spacewar! Events
@section Spacewar! Events
Obviously our Spacewar! game handles events. First to control the
ships with the keyboard. Secondly, we want the game to pause/to resume
when the mouse cursor moves out/in of the game play.

In our design, an unique morph, @class{SpaceWar} instance, models the
game play. Therefore we want this instance to handle the events
described above.

@cindex event, mouse
@cindex mouse
@subsection Mouse event
We want to catch event when the mouse cursor moves over our
@class{SpaceWar} morph.

@exercise{Get notified of mouse move over event, handleMouseOver,
@emph{Which method should returns true to let the game play be notified
with dedicated messages the mouse cursor enters or leaves? In which
class should we implement this method?}}

Once we make explicit we want the game play to receive mouse move over
events, we need to set the behavior accordingly with dedicated
methods.

Each time the mouse cursor enters the game play, we want:

@itemize

  @item @strong{Keyboard focus.} It follows the mouse cursor: the
  keyboard input goes to the morph under the mouse cursor. In @cuis{},
  the mouse cursor is modeled as a @class{HandMorph} instance, an
  event object (see event classes hierarchy at the beginning of this
  chapter). An event object is interrogated about its hand with the
  @msg{hand} message. All in all, we want the keyboard focus to be
  targeted toward our game play:

  @smalltalkExample{event hand newKeyboardFocus: self}

  @item @strong{Resume the game.} The continuous update of the game is
  done through a dedicated process called stepping mechanism; it will
  be discussed in the next chapter. The game play just asks itself to
  resume the stepping:
  @smalltalkExample{self startStepping} 
@end itemize

@exercise{Handle mouse enter event, mouseEnter, @emph{Which message is
sent to the game play to be notified the mouse cursor enter the game
play area?  How should be written the matching method?}}

@cindex event, keyboard
@subsection Keyboard event
