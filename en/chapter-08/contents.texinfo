@node Events
@chapter Events

@heading What just happened?

We talked above about control flow, how one makes decisions about what
to do in making calculations.  We talked about this like the entire
computer processing resource was dedicated to this task. But it isn't
so.

Computers may be fast at some calculations, but they are only so fast,
and when there are many things to do, one shares and takes turns.

So aside from @emph{do this and then do that}, @dfn{event}s happen.

Also, a computer may be fast enough that it literally has
@emph{nothing} to do.  What does it do then?  When a processor
@emph{goes to sleep}, how do we get its attention?

You are reading the right chapter to know.

@section System Events

Modern integrated @dfn{System On a Chip} (@dfn{SOC}) hardware has many
circuits which are active at the same time.  So one kind of event is
sensing something happening in the world.  Class @class{EventSensor}
handles keyboard key press and mouse @dfn{hardware interrupts},
translating between hardware signals and software event objects.

In @cuis{}, the class @class{MorphicEvent} and its subclasses
represent the diversity of events in the system.  Basically, a morph
@emph{raises its hand} and says what events, if any, it is interested
in receiving. Then it implements methods to get the event objects
holding the information of the captured events.

As @class{MouseMoveEvent}s are generated, the @class{HandMorph}
adjusts its screen position.  When mouse and keystroke events arrive,
the @class{HandMorph} coordinates the ``dispatch'' of events to the
proper morph under the hand as well as displaying tool tips and
carrying morphs in transit during drag operations.

As we saw in the previous chapter with @class{ColorClickEllipse}, any
morph may override default @class{Morph} methods to assert that it
handles various user events and the methods which take the associated
event objects when events arrive.

Basically, user input events are generated, a @class{HandMorph}
reflects any cursor movement, morphs react to events, each long running
task gets a time slice and makes some progress,
any display changes are updated on the screen, and the next step
happens.  Time marches forward a step.

This happens over and over and over,
keeping the juggler's illusion that all balls
in the air are moving at once.  Underneath, the balls are each moving
just a bit, in sequence.






