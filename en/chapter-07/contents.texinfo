@node The Fundamentals of Morph
@chapter The Fundamentals of Morph

@quotation
Simple things should be simple and complex things should be possible.
@author Alan Kay
@end quotation

@* @* @* @*



What would we expect if we ask for good support for building GUIs in a
programming system?

In @ref{Visual with Morph} we started with that same question, and
gave an overview of Morphs and their interactive behavior. This
chapter deals with how Morphs are built, how to create new Morphs and
what rules they follow.

@cindex moprh @subentry legacy
The User Interface framework in @cuis{} is called Morphic. Morphic was
origianlly created by Randy Smith and John Maloney as the
@url{https://bibliography.selflanguage.org/_static/self4.0UserInterface.pdf,,UI
for Self}. Later, John Maloney ported it to Smalltalk, to be used as
the
@url{http://stephane.ducasse.free.fr/FreeBooks/CollectiveNBlueBook/morphic.final.pdf,,UI
for Squeak}.


@menu
* Going Vector::
* A Clock Morph::
@end menu


@node Going Vector
@section Going Vector

For @cuis{}, we built Morphic 3, the third design iteration of these
ideas, after Self's Morphic 1 and Squeak's Morphic 2. If you already
know Morphic in Self or Squeak, most concepts are similar, although
with some improvements: Morphic 3 coordinates are not limited to being
integer numbers, the apparent size (zoom level) of elements is not
tied to pixel density, and all drawing is done with high quality
(subpixel) anti aliasing. These enhancements are enabled by the huge
advance in hardware resources since Self and Squeak were designed (in
the late 80's and late 90's respectively). Additionally, careful
design of the framework relieves Morph programmers from much the
complexity that was required, especially with regards to geometry.

This step is required until VectorGraphics become part of the base
@cuis{} image:

@cindex morph @subentry vector @subentry installation
@smalltalkExample{Feature require: 'VectorGraphics'}

@subsection A first example

Let's start with some examples. What we want is to build our own
graphic objects, or Morphs. A Morph class is part of the Morph
hierarchy and usually includes a @method{drawOn:} method for drawing
its distinctive appearance. If we forget about computers for a second,
and consider drawing with color pens on a sheet of paper, one of the
most basic things we can do is to draw straight lines.

So, let's start a System Browser window and build a straight line
object:

@smalltalkExample{Morph subclass: #LineExampleMorph
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Morphic-Learning'}

In method category @label{drawing} add:

@cindex morph @subentry vector @subentry line drawing
@cindex morph @subentry @method{drawOn:}
@smalltalkExample{LineExampleMorph>>drawOn: aCanvas
   aCanvas strokeWidth: 20 color: Color green do: [
      aCanvas
         moveToX: 100 y: 100;
         lineToX: 400 y: 200 ].}

Now in a Workspace execute:
@smalltalkExample{LineExampleMorph new openInWorld}

If you get a prompter asking whether to install and activate Vector
Graphics support, please answer yes. There it is. You have already
built your first @class{Morph} class.

@figure{Details of our line morph,ch07-01-LineDetails,10}

The code is self evident, the @method{drawOn:} method takes a
@class{VectorCanvas} instance as an argument. @class{VectorCanvas}
provides many drawing operations for morphs to use. You can play with
the various drawing operations and their parameters, and see the
result. If you make a mistake, and the @method{drawOn:} method fails,
you'll get a red and yellow error box. After fixing your
@method{drawOn:} method, do ...@clicksequence{World menu @click{}
@label{Debug...} @click{} @label{Start drawing all again}}.. to get
your morph redrawn correctly.

@exercise{Cross morph, exeCrossMorph,@emph{How will you modify our
line morph so it draws itself as a cross with an extent of 200
pixels?}}


@subsection Morph you can move
@cindex morph @subentry movable
You might have already tried to click and drag on your Line, like you
can do with regular windows and most other Morphs. If not, try
now. But nothing happens! The reason is that our Morph is fixed in a
place in the owner morph (the WorldMorph). It is fixed because
@method{drawOn:} says it should be a line between @smalltalk{100@@100}
and @smalltalk{400@@200}. Moving it around would mean modifying those
points. That could be possible, for example, if the points were stored
in instance variables.

But now, we just want to code our morph in the simplest possible way,
and still be able to move it around. The solution is to make it
subclass of @class{MovableMorph}, instead of @class{Morph}.

@cindex morph @subentry @method{delete}
To do this, first evaluate the code below to get rid of all of them:

@smalltalkExampleCaption{Delete all instances of a given morph,deleteMorphInstances,
LineExampleMorph allInstancesDo: [ :m | m delete]}

Then, in the System Browser, in the class declaration, type
@class{MovableMorph} instead of @class{Morph} and save. Now execute
again:

@smalltalkExample{LineExampleMorph new openInWorld}

@cindex morph @subentry @smalltalk{location}
You will get a line you can grab with the mouse and move it
around. @class{MovableMorph} adds a new instance variable called
@smalltalk{location}. If a morph has a @smalltalk{location}, it can be
moved around, by modifying it. The @smalltalk{location} also defines a
new local coordinate system. All the coordinates used in the
@method{drawOn:} method are now relative to this new coordinate
system. That's why we don't need to modify the @method{drawOn:}
method. @method{drawOn:} now tells how the morph should be drawn, but
not where. The @smalltalk{location} also specifies a possible rotation
and scale factor. This means that subinstances of @class{MovableMorph}
can also be rotated and zoomed.


@subsection Filled morph
Let's build another morph, to have more fun.

@smalltalkExample{MovableMorph subclass: #TriangleExampleMorph
   instanceVariableNames: 'borderColor fillColor'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Morphic-Learning'}

In method category @label{initialization} add:

@smalltalkExample{TriangleExampleMorph>>initialize
   super initialize.
   borderColor @assign{} Color random alpha: 0.8.
   fillColor @assign{} Color random alpha: 0.6.}

In the @label{drawing} method category add:

@cindex morph @subentry vector @subentry filling area
@cindex morph @subentry @method{drawOn:}
@smalltalkExample{TriangleExampleMorph>>drawOn: aCanvas
   aCanvas strokeWidth: 10 color: borderColor fillColor: fillColor do: [
      aCanvas
         moveToX: 0 y: 100;
         lineToX: 87 y: -50;
         lineToX: -87 y: -50;
         lineToX: 0 y: 100 ].}

Take a moment to understand that code, to guess what it will do. Now
execute:

@smalltalkExample{TriangleExampleMorph new openInWorld}

Do it several times, and move each triangle around. Each new triangle
you create has different colors. And these colors are not completely
opaque. This means that when you place your triangle over some other
morph, you can see through it.

@figure{A variety of triangle morphs@comma{} one decorated with its halo,ch07-02-Triangles,6} 


@exercise{Rectangle morph, exeRectMorph, @emph{How will you write a
movable rectangle morph with an extent of 200 per 100? The rect will
be filled with a random translucent color and surrounded by a thin
blue line.}}


As we learnt previously, Morphic gives you additional ways to interact
with your morphs. With a three buttons mouse, or a wheel mouse, place
the mouse pointer (a @class{HandMorph} instance) over one of your
triangles and click with the center button or mouse. If you don't have
a three buttons mouse do @kbd{Command-click}. You get a constellation
of small colored circles around your morph. This is called the morph's
@dfn{halo}, and each colored circle is a @dfn{halo
handle}. @xref{ch07-02-Triangles}.

At the top left you have the red @label{Remove} handle. Clicking on it
just removes the morph from the morphic world. Hover your hand over
each handle, and you'll get a tooltip with its name. Other handles let
you @label{Duplicate} a morph, open a @label{Menu} with actions on it,
@label{Pick up} (same as dragging it with the the mouse as you did
before). The @label{Move} operation is similar to @label{Pick up}, but
doesn't remove the morph from the current owner. More about that,
later. The @label{Debug} handle opens a menu from where you can open
an Inspector or a Hierarchy Browser to study the morph.

You also have a @label{Rotate} and @label{Change scale} handles. Try
them! To use them, move your hand to the handle, and then press the
mouse button and drag it. As you might have guessed, the rotate
handles spins your morph around its @smalltalk{0@@0} coordinates
(i.e. the origin of its own coordinate system). The scale handles
controls the apparent zoom applied to your morph. Both scale and
rotation (and also displacement, as when you move your morph around)
are implemented by modifying the inner coordinate system defined by
your morph. Displacement, rotation and scale are floating point
numbers, and thus not limited to integers.

We will learn how to control all this with code and animate our morph.

@exercise{Rotate your rectangle morph arround its center,exeRotateRect,
@emph{Rotate your rectangle morph. Does it rotate around its center or
around one corner? If necessary rewrite your rectangle morph so it rotates
around its center.}}

@subsection Animated morph
@cindex morph @subentry animated
Let's add two methods to our @class{TriangleExampleMorph} to
make our triangle @emph{alive}:

@cindex morph @subentry @method{step,wantsSteps}
In the method category @label{stepping} define:
@smalltalkExample{TriangleExampleMorph>>wantsSteps
   @return{} true}

...and:
@smalltalkExample{TriangleExampleMorph>>step
   fillColor @assign{} Color random.
   self redrawNeeded}

Then create some additional triangles as you did before.

This will make our triangles change color once a second. But more
interesting, edit the method:

@smalltalkExample{TriangleExampleMorph>>stepTime
   @return{} 100}

...and:

@cindex morph @subentry @method{morphPosition}

@smalltalkExample{TriangleExampleMorph>>step
   self morphPosition: self morphPosition + (0.4@@0).
   self redrawNeeded}

Now, our morph steps ten times per second, and moves to the right at a
speed of four pixels per second. At each step it moves by 0.4 pixels,
and not by an integer number of pixels. High quality anti-aliasing
drawing means we can actually do that! You can make it step for times
a second, and move 1 pixel each time, and see how different that
looks.

Now try this:

@cindex morph @subentry @method{rotateBy:}

@smalltalkExample{TriangleExampleMorph>>step
   self morphPosition: self morphPosition + (0.2@@0).
   self rotateBy: 4 degreesToRadians.
   self redrawNeeded}

It gets even better. First get rid of all instances:
 
@smalltalkExample{TriangleExampleMorph allInstancesDo: [ :m | m delete]}

And modify these methods:

@smalltalkExample{TriangleExampleMorph>>initialize
   super initialize.
   borderColor @assign{} Color random alpha: 0.8.
   fillColor @assign{} Color random alpha: 0.6.
   scaleBy @assign{} 1.1}

Accept @smalltalk{scaleBy} as a new instance variable of the
@class{TriangleExampleMorph} class.

@smalltalkExample{TriangleExampleMorph>>step
   self morphPosition: self morphPosition + (0.2@@0).
   self rotateBy: 4 degreesToRadians.
   self scaleBy: scaleBy.
   self scale > 1.2 ifTrue: [scaleBy @assign{} 0.9].
   self scale < 0.2 ifTrue: [scaleBy @assign{} 1.1].
   self redrawNeeded}

Then create a new triangle:
@smalltalkExample{TriangleExampleMorph new openInWorld}

See that when the triangle is doing its crazy dance, you can still
open a halo and interact with it.

@iftex
   @figure{Animated morph,ch07-03-AnimatedMorph,10}
@end iftex

@ifhtml
   @figureExt{Animated morph,ch07-03-AnimatedMorph,10,.gif}
@end ifhtml


@subsection Morph in morph
@cindex morph @subentry submorph

Now, let's try something different. Grab one of your
@class{LineExampleMorph}. With the halo, zoom it until it is about the
size of your triangle. Now place the triangle above your line. Open a
halo on the triangle, click on the @label{Menu} handle and select
...@clicksequence{@label{embed into} @click{}
@label{LineExampleMorph}}. This makes the triangle a submorph of the
line. Now, if you move, scale or rotate the line, the triangle also
gets adjusted.

You can open a halo on the triangle. To do this, middle-click twice
over it. With the halo on the triangle, you can rotate or zoom it
independently of the line. Also note that when you grab the triangle
with your hand (not using the halo), you grab the
line@tie{}+@tie{}triangle composite. You can't just drag the triangle
away. For this, you need the triangle's halo. Use its @label{Move}
handle@footnote{By now, it is likely that the triangle walked quite a
bit!} to position it without @emph{getting it out} of the line. Use
its @label{Pick up} handle to take it with the hand and drop
it in the world. Now, the triangle is no longer submorph of the line,
and they can be moved, rotated or scaled independently.

But let's try something. Make the triangle submorph of the line
again. Now add the following method to category @label{geometry
testing} of the class @class{LineExampleMorph}:

@cindex morph @subentry @method{clipsSubmorphs}

@smalltalkExample{LineExampleMorph>>clipsSubmorphs
   @return{} true}

The drawing of the triangle gets cut exactly at the bounds of the
line. This is most useful for implementing scrolling panes that only
make a part of their contents visible, but might have other uses too.

@figure{An animated and clipped submorph
triangle,ch07-04-AnimatedAndClippedSubmorph,6}


@node A Clock Morph
@section A Clock Morph
With all the things we have already learned, we can build a more
sophisticated morph. Let's build a @class{ClockMorph} as see in
@ref{ch07-05-Clock}. In order to have a default text font based on
vector graphics, do ...@clicksequence{World menu @click{}
@label{Preferences...} @click{} @label{Set System Font...} @click{}
@label{DejaVu...} @click{} @label{DejaVuSans}}@footnote{You can select
any other TrueType font from the ones available}.


@figure{A clock morph,ch07-05-Clock,4}

Let's create @class{ClockMorph}, the dial clock :

@smalltalkExample{MovableMorph subclass: #ClockMorph
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Morphic-Learning'}

@cindex morph @subentry @method{drawOn:}
...and its drawing method in the category @label{drawing}:

@smalltalkExampleCaption{Drawing the clock dial, clockDialDrawing,
ClockMorph>>drawOn: aCanvas
   aCanvas
      ellipseCenterX: 0 y: 0 rx: 100 ry: 100
      borderWidth: 10
      borderColor: Color lightCyan
      fillColor: Color veryVeryLightGray.
   aCanvas drawString: 'XII' at: -13 @@ -90 font: nil color: Color brown.
   aCanvas drawString: 'III' at: 66 @@ -10 font: nil color: Color brown.
   aCanvas drawString: 'VI' at: -11 @@ 70 font: nil color: Color brown.
   aCanvas drawString: 'IX' at: -90 @@ -10 font: nil color: Color brown}


We create @class{ClockHourHandMorph}, the hand for the hours:

@smalltalkExample{MovableMorph subclass: #ClockHourHandMorph
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Morphic-Learning'}

...and its drawing method in the category @label{drawing}:

@smalltalkExample{ClockHourHandMorph>>drawOn: aCanvas
   aCanvas fillColor: (Color black alpha: 0.6) do: [
      aCanvas
         moveToX: -10 y: 0;
         lineToX: 0 y: 5;
         lineToX: 50 y: 0;
         lineToX: 0 y: -5;
         lineToX: -10 y: 0 ].}

You can start playing with them. We could use several instances of a
single @class{ClockHandMorph}, or create several classes. Here we
chose to do the latter. Note that all the @method{drawOn:} use
hardcoded constants for all coordinates. As we have seen before, this
is not a limitation. We don't need to write a lot of trigonometric and
scaling formulas to build Morphs in @cuis{}!

By now, you might imagine what we are doing with all this, but please
stick with us while we finish building our clock.

We create @class{ClockMinuteHandMorph}, the hand for the minutes:

@smalltalkExample{MovableMorph subclass: #ClockMinuteHandMorph
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Morphic-Learning'}

...and its drawing method in the category @label{drawing}:

@smalltalkExample{ClockMinuteHandMorph>>drawOn: aCanvas
   aCanvas fillColor: ((Color black) alpha: 0.6) do: [
      aCanvas
         moveToX: -8 y: 0;
         lineToX: 0 y: 4;
         lineToX: 82 y: 0;
         lineToX: 0 y: -4;
         lineToX: -8 y: 0 ]}

And finally, the @class{ClockSecondHandMorph}, the hand for the seconds:

@smalltalkExample{MovableMorph subclass: #ClockSecondHandMorph
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Morphic-Learning'}

...and its drawing method in the category @label{drawing}:

@smalltalkExample{ClockSecondHandMorph>>drawOn: aCanvas
   aCanvas strokeWidth: 1.5 color: Color red do: [
      aCanvas
         moveToX: 0 y: 0;
         lineToX: 85 y: 0 ]}

Now, all that is needed is to put our clock parts together in
@class{ClockMorph}. In its method category @label{initialization} add
its @method{initialize} method (accept the new names as instance
variables):

@smalltalkExample{ClockMorph>>initialize
   super initialize.
   self addMorph: (hourHand @assign{} ClockHourHandMorph new).
   self addMorph: (minuteHand @assign{} ClockMinuteHandMorph new).
   self addMorph: (secondHand @assign{} ClockSecondHandMorph new)}

Finally, we animate it. In method category @label{stepping} add the
method:

@smalltalkExample{ClockMorph>>wantsSteps
   @return{} true}

...and:

@smalltalkExample{ClockMorph>>step
   | time |
   time @assign{} Time now.
   hourHand rotation: (time hour * 30 - 90) degreesToRadians.
   minuteHand rotation: (time minute * 6 - 90) degreesToRadians.
   secondHand rotation: (time second * 6 - 90) degreesToRadians.}

Take a look at how we update the clock hands.

As we said before, any @class{MovableMorph} defines a coordinate
system for its own @method{drawOn:} method and also for its
submorphs. This new coordinate system might include rotation or
reflexion of the axis, and scaling of sizes, but by default they
don't. This means that they just translate the origin, by specifying
where in the owner point @smalltalk{0@@0} is to be located.

The World coordinate system has @smalltalk{0@@0} at the top left
corner, with X coordinates increasing to the right, and Y coordinates
increasing downwards. Positive rotations go clockwise. This is the
usual convention in graphics frameworks. Note that this is different
from the usual mathematics convention, where Y increases upwards, and
positive angles go counterclockwise.

So, how do we update the hands? For example, for the hour hand, one
hour means 30 degrees, as 12 hours means 360 degrees or a whole
turn. We multiply hours by 30 to get degrees. But for 0 the hand must
point up, that is -90 degrees in our coordinate system. So we
substract 90. Then we convert to radians, the unit expected by the
@method{rotation:} method. Minute and second hand work in a similar
way, but as there are 60 minutes in one hour, and 60 seconds in one
minute, we need to multiply them by 6 to get degrees. As rotation is
done around the origin, and the clock has set the origin at its center
(@ref{clockDialDrawing}), there's no need to set the position of the
hands. Their @smalltalk{0@@0} origin will therefore be at the clock
@smalltalk{0@@0}, i.e. the center of the clock.

@figure{A fancy clock morph,ch07-06-ExerciseClock,4}

@exercise{A fancy clock, exeFancyClock, @emph{Look at the clock on
@ref{ch07-06-ExerciseClock}. Don't you think its hand for the seconds
decorated with a red and yellow disc is fancy? How will you modify our
clock morph to get this result?}}

Create some instances of your clock: @smalltalk{ClockMorph new
openInWorld}. You can rotate and zoom. Look at the visual quality of
the Roman numerals in the clock face, especially when rotated and
zoomed. You don't get this graphics quality on your regular
programming environment! You can also extract the parts, or scale each
separately. Another fun experiment is to extract the Roman numerals
into a separate @class{ClockFaceMorph}, and make it submorph of the
Clock. Then, you can rotate just the face, not the clock, and the
clock will show fake time. Try it!


You might have noted two things that seem missing, though: How to
compute bounding rectangles for Morphs, and how to detect if a Morph
is being hit by the Hand, so you can move it or get a halo. The
display rectangle that contains a morph is needed by the framework to
manage the areas of the Display that need to be updated as a result of
any change. But you don't need to know this rectangle in order to
build your own Morphs. In @cuis{}, the framework computes it as
needed, and stores it in the @smalltalk{privateDisplayBounds}
variable. You don't need to worry about that variable at
all. @todo{WRT: what is it?} detecting if a Morph is hit by the Hand,
or more generally, if a pixel belongs to a Morph, truth is that when a
Morph is drawn, the framework indeed knows all the pixels it is
affecting. The @method{drawOn:} method already specifies the shape of
the Morph. Therefore, there is no need to ask the programmer to code
the Morph geometry again in a separate method! All that is needed is
careful design of the framework itself, to avoid requiring programmers
to handle this extra complexity.

The ideas we have outlined in this chapter are the fundamental ones in
Morphic, and the framework is implemented in order to support
them. Morphs (i.e. interactive graphic objects) are very general and
flexible. They are not restricted to a conventional widgets library,
although such a library (rooted in @class{WidgetMorph}) is included
and used for building all the Smalltalk tools.

The examples we have explored use the VectorGraphics package. This
package includes VectorCanvas and HybridCanvas classes. However,
installing this package is not required for using the regular
Smalltalk tools you have been using. The reason is that Cuis includes
by default the @class{BitBltCanvas} class inherited from Squeak (and
called @class{FormCanvas} there). @class{BitBltCanvas} doesn't support
the vector graphics drawing operations and doesn't do anti-aliasing or
zooming. But it is mature, and it relies on the BitBlt operation that
is included in the virtual machine. This means that it offers
excellent performance.

VectorGraphics is still in active development. When its drawing
performance becomes good enough, it will be possible to draw all
Morphs, completely replacing BitBltCanvas. Then, the UI customization
option 'World' / 'Preferences...' / 'Font Sizes...' will no longer be
needed, as all windows will be zoomable, in addition to resizable.

To further explore Cuis' Morphic, evaluate `Feature require: 'SVG'`,
and then `SVGElementMorph examplesLion` and the other examples
there. Also, be sure to try the example in the comment in
#unicodeExamples.
