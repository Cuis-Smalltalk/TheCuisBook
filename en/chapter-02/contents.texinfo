@node The Message Way Of Life
@chapter The Message Way Of Life


@menu
* Smalltalk design::
* Messages sends definition::
* Message to string entities::
* Messages to number entities::
@end menu

@node Smalltalk design
@section Smalltalk design

Smalltalk design is based on entites communicating with each other
through messages. That's all, there is nothing more.

When a given entity receives a message from another entity, it
triggers a specific behavior.  The receiving entity of the message is
called the @dfn{receiver} and the sending entity, the @dfn{sender}. In
@cuis{} terminology, an entity is called an @dfn{instance of a class}
or @dfn{class instannce}. A class is a kind of model for an entity.

The behavior is defined internally in the receiver and it can be
triggered from any instance. Again this behavior is described only
with messages sending to other entities including the self entity. The
behavior is defined in a class, it is called a @dfn{method}.

It results in a huge cloud of entities communicating with each other
through message sending. New entities are instantiated when needed
then automatically garbage collected when not required anymore. On a
fresh @cuis{} environment, the instances class count is higher than
150'000.

@smalltalkExampleCaption{Counting the number of entities, entitiesCount,
ProtoObject allSubclasses inject: 0 into: [:count :class |
   count + class allInstances size] 
@result{} 152058}

To be honest, in our previous chapter we skipped this important detail
on Smalltalk design. We did not want to afraid you with this radical
design. The scripts you read and write were all about entities
communicating with each other through messages.


@todo{SystemWindows. Text editor menus. Keyboard shortcuts.}

@cindex message, send
@cindex message, unary
@cindex message, binary
@cindex message, keyword
@node Messages sends definition
@section Message sends definition
There are three kinds of messages in @cuis{}:

@itemize

 @item @strong{Unary messages} take no argument.
 @*
 @smalltalk{1 factorial} sends the message @msg{factorial} to the object
 @smalltalk{1},

 @item @strong{Binary messages} take exactly one argument.
 @*
 @smalltalk{1 + 2} sends the message @msg{+} with argument
 @smalltalk{2} to the object @smalltalk{1}.

 @item @strong{Keyword messages} take an arbitrary number of
 arguments.
 @*
 @smalltalk{2 raisedTo: 6 modulo: 10} sends the message
 consisting of the message selector @msg{raisedTo:modulo:} and the
 arguments @smalltalk{6} and @smalltalk{10} to the object
 @smalltalk{2}.

@end itemize

Unary message selectors consist of alphanumeric characters, and start
with a lower case letter.

Binary message selectors consist of one or more characters from the
following set:

@smalltalkExample{+ -- / \ * âˆ¼ < > = @@ % | & ? ,}

Keyword message selectors consist of a series of alphanumeric
keywords, where each keyword starts with a lower-case letter and ends
with a colon.

@cindex message, precedence
Unary messages have the highest precedence, then binary messages, and
finally keyword messages, so:

@smalltalkExample{2 raisedTo: 1 + 3 factorial
@result{} 128}

First we send @smalltalk{factorial} to @smalltalk{3}, then we send
@smalltalk{+ 6} to @smalltalk{1}, and finally we send
@smalltalk{raisedTo: 7} to @smalltalk{2}.

Precedence aside, evaluation is strictly from left to right, so

@smalltalkExample{1 + 2 * 3
@result{} 9}

is not 7. Parentheses must be used to alter the order of evaluation:

@smalltalkExample{1 + (2 * 3)
@result{} 7}

@cindex cascade of messages
In the @ref{hello2} example, the message @msg{show:} and @msg{newLine}
are sent to the same @class{Transcript} entity. In such circumstance,
we can use the @dfn{cascade} technique to avoid this repetition. The
receiver @class{Transcript} is written once and the sent messages are
separated by semicolon:

@smalltalkExampleCaption{Cascade of message, helloCascade,
Transcript
   show: 'Hello World!';
   newLine;
   show: 'I am Cuising'}

Observe the text here is formatted to ease code understanding. It is possible to
write the cascade of messages in one line, but it reduces the
readability of the code:

@smalltalkExample{Transcript show: 'Hello World!'; newLine; show: 'I am Cuising'}

The @class{Transcript} class is frequently helpful in presenting
useful information when developing an application. As an alternative
to the @kbd{Ctrl-d} shortcut, @kbd{Ctrl-p} (@emph{@b{P}rint it})
executes the script and prints the result direcly in the Workspace.

In the example, we have requested no special result.  Selecting the
text and typing @kbd{Ctrl-p} results in the default, which is to
return the object to which a message is sent, in this case the
@class{Transcript}.

@node Message to string entities
@section Message to string entities
@cindex string, character access
Access to a character in a string is done with the keyword message
@msg{at:} and its index position in the string. Execute the following
examples with the @kbd{Ctrl-p} shortcut:

@smalltalkExample{'Hello' at: 1 @result{} $H
'Hello' at: 5 @result{} $o}

Observe how a character is prefixed with the ``$'' symbol.

@strong{Caution.} The index position starts naturally from 1 to the
string length.

To change one character, use the companion two keywords message
@msg{at:put:}. The argument must be noted as a character:
@smalltalkExample{'Hello' at: 2 put: $a; yourself
@result{} 'Hallo'}

Observe the use of the cascade with the @msg{yourself} message. It is
sent to the instance string to get it returned.

@exercise{Hello to Belle,helloBelle, @emph{Replace each character of
the string 'Hello' to become 'Belle'}}

@cindex character, ascii
Character can be converted to integer and integer to character:
@smalltalkExample{$A asciiValue @result{} 65
(65 + 25) asCharacter @result{} $Z}

@cindex string, shuffled
@cindex collection, shuffled
Shuffling a string is funny but without much use. Nevertheless,
shuffling apply to any kind of collection, not only to string, and it
proves to be of some use as we may see later:
@smalltalkExample{'hello world' shuffled
@result{} 'wod llreohl'}

@cindex string, sorted
We can write the same about sorting a string:
@smalltalkExample{'bonjour' sorted
@result{}#($b $j $n $o $o $r $u)}

@node Messages to number entities
@section Messages to number entities
@cindex number, root
@cindex number, sqrt
@cindex number, squared

Earlier, we discussed how @cuis{} knows about rational number.  All
four arithmetic operations and mathematical functions are compatible
with the rational number representation:
@smalltalkExample {(15 / 14) * (21 / 5) @result{} 9 / 2
(15 / 14) / ( 5 / 21) @result{} 9 /2 
(3 / 4) squared @result{} 9 / 16
(25 / 4) sqrt @result{} 5 / 2}

@exercise{Sum of the squares,squaredSum,Write the code to compute the
sum of the squares of the inverse of the first four integers.}

@cindex number, decimal division
If @cuis{} divides integer as rational number, how to compute the
decimal division? One option is to write a number as a @dfn{Float}, it
is the decimal representation in programming language, the integer
part and fractional parts are separated by a dot ``.'':
@smalltalkExample{ 15.0 / 4 @result{}3.75
15 / 4.0 @result{} 3.75}

Another option is to convert an integer to a float with the
@msg{asFloat} message. It is very useful when the integer is in a
variable:

@smalltalkExample{15 asFloat / 4
@result{} 3.75}

@cindex number, integer division
Alternatively to the decimal division, you ask integer division with
the message @msg{//}:
@smalltalkExample{15 // 4
@result{} 3}

@cindex number, division reminder
The reminder of the Euclidean division is computed with the message
@msg{\\\\}:
@smalltalkExample{15 \\\\ 4
@result{} 3}

@cindex number, odd
@cindex number, even
@cindex number, isPrime
@cindex number, isDivisibleBy:
@cuis{} knows some arithmetic operations to test if an integer is an
odd, even, prime number or divider. You just send the appropriate
unary or keyword message to the number:

@smalltalkExampleCaption{Testing on integer,integerBasicTest,
25 odd @result{} true
25 even @result{} false
25 isPrime @result{} false
23 isPrime @result{} true
91 isDivisibleBy: 7 @result{} true
117 isDivisibleBy: 7 @result{} false
117 isDivisibleBy: 9 @result{} true}

@cindex number, gcd:
@cindex number, lcm:
With specific @dfn{keyword messages} you compute the Least Common
Multiple and Greatest Common Divisor. A keyword message is composed of
one or several colon(s) ``:'' to insert argument(s):

@smalltalkExample{12 lcm: 15 @result{} 60
12 gcd: 15 @result{} 3}


