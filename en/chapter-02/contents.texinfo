@node The Message Way of Life
@chapter The Message Way of Life

Smalltalk design is based on entities communicating with each other
through messages. That's all, there is nothing more.


@menu
* Communicating entities::
* Messages sends definition::
* Message to string entities::
* Messages to number entities::
* A brief introduction to the system Browser::
* Spacewar! models::
@end menu

@node Communicating entities
@section Communicating entities

@cindex message, sender
@cindex message, receiver
When a given entity receives a message from another entity, it
triggers a specific behavior.  The receiving entity of the message is
called the @dfn{receiver} and the sending entity, the @dfn{sender}. In
@cuis{} terminology, an entity is called an @dfn{instance of a class}
or @dfn{class instance}. A @dfn{class} is a kind of model for an entity.

The behavior is defined internally in the receiver and it can be
triggered from any instance. Again this behavior is described only
with messages sent between entities.  An entity may send a message to
itself. A behavior is defined in a class, and is called a @dfn{method}.

It results in a huge cloud of entities communicating with each other
through message sending. New entities are instantiated when needed
then automatically garbage collected when no longer required. On a
fresh @cuis{} environment, the instances class count is more than
150000.

@cindex collection, @method{inject:into:}
@smalltalkExampleCaption{Calculating the number of entities, entitiesCount,
ProtoObject allSubclasses inject: 0 into: [:count :class |
   count + class allInstances size] 
@result{} 152058}

The count of classes, the models for the entities -- class instances
-- is more than 1000.

@smalltalkExampleCaption{Calculating the number of classes, classesCount,
ProtoObject allSubclasses size
@result{} 1173}

To be honest, in our previous chapter we skipped this important detail
on Smalltalk design. We wrote about message sending without explaining
much, we wanted you to discover informally this design.
The scripts you
read and wrote were all about entities communicating with each other
through messages.


@todo{SystemWindows.}

@todo{Text editor menus.}

@todo{Keyboard shortcuts.}

@cindex message, send
@cindex message, unary
@cindex message, binary
@cindex message, keyword
@node Messages sends definition
@section Message sends definition
There are three kinds of messages in @cuis{}:

@itemize

 @item @strong{Unary messages} take no argument.
 @*
 @smalltalk{1 factorial} sends the message @msg{factorial} to the object
 @smalltalk{1},

 @item @strong{Binary messages} take exactly one argument.
 @*
 @smalltalk{1 + 2} sends the message @msg{+} with argument
 @smalltalk{2} to the object @smalltalk{1}.

 @item @strong{Keyword messages} take an arbitrary number of
 arguments.
 @*
 @smalltalk{2 raisedTo: 6 modulo: 10} sends the message
 consisting of the message selector @msg{raisedTo:modulo:} and the
 arguments @smalltalk{6} and @smalltalk{10} to the object
 @smalltalk{2}.

@end itemize

Unary message selectors consist of alphanumeric characters, and start
with a lower case letter.

Binary message selectors consist of one or more characters from the
following set:

@smalltalkExample{+ -- / \ * ~ < > = @@ % | & ? ,}

Keyword message selectors consist of a series of alphanumeric
keywords, where each keyword starts with a lower-case letter and ends
with a colon.

@cindex message, precedence
Unary messages have the highest precedence, then binary messages, and
finally keyword messages, so:

@smalltalkExample{2 raisedTo: 1 + 3 factorial
@result{} 128}

First we send @smalltalk{factorial} to @smalltalk{3}, then we send
@smalltalk{+ 6} to @smalltalk{1}, and finally we send
@smalltalk{raisedTo: 7} to @smalltalk{2}.

Precedence aside, evaluation is strictly from left to right, so

@smalltalkExample{1 + 2 * 3
@result{} 9}

is not 7. Parentheses must be used to alter the order of evaluation:

@smalltalkExample{1 + (2 * 3)
@result{} 7}

@cindex cascade of messages
In the @ref{hello2} example, the message @msg{show:} and @msg{newLine}
are sent to the same @class{Transcript} entity. In such circumstance,
we can use the @dfn{cascade} technique to avoid this repetition. The
receiver @class{Transcript} is written once and the sent messages are
separated by semicolon:

@smalltalkExampleCaption{Cascade of message, helloCascade,
Transcript
   show: 'Hello World!';
   newLine;
   show: 'I am Cuising'}

Observe the text here is formatted to ease code understanding. It is possible to
write the cascade of messages in one line, but it reduces the
readability of the code:

@smalltalkExample{Transcript show: 'Hello World!'; newLine; show: 'I am Cuising'}

The @class{Transcript} class is frequently helpful in presenting
useful information when developing an application. As an alternative
to the @kbd{Ctrl-d} (@emph{@b{D}o it}) shortcut, @kbd{Ctrl-p} (@emph{@b{P}rint it})
executes the script and prints the result direcly in the Workspace.

In the example, we have requested no special result.  Selecting the
text and typing @kbd{Ctrl-p} results in the default, which is to
return the object to which a message is sent, in this case the
@class{Transcript}.

@node Message to string entities
@section Message to string entities
@cindex string, character access
Access to a character in a string is done with the keyword message
@msg{at:} and its index position in the string. Execute the following
examples with the @kbd{Ctrl-p} shortcut:

@smalltalkExample{'Hello' at: 1 @result{} $H
'Hello' at: 5 @result{} $o}

Observe how a character is prefixed with the ``$'' symbol.

@strong{Caution.} The index indicates position naturally from 1 to the
string length.

To change one character, use the companion two keyword message
@msg{at:put:}. The argument must be noted as a character:
@smalltalkExample{'Hello' at: 2 put: $a; yourself
@result{} 'Hallo'}

Observe the use of the cascade with the @msg{yourself} message.
A cascade sends following messages to the original receiver,
so #yourself returns the updated string.
Without the cascade, $a is returned as the result of the #at:put: message.

@exercise{Hello to Belle,helloBelle, @emph{Replace each character of
the string 'Hello' to become 'Belle'}}

@cindex character, ascii
Character can be converted to integer and integer to character:
@smalltalkExample{$A asciiValue @result{} 65
(65 + 25) asCharacter @result{} $Z}

@cindex string, @method{shuffled}
@cindex collection, @method{shuffled}
Shuffling a string is funny but without much use. Nevertheless,
shuffling apply to any kind of collection, not only to string, and it
proves to be of some use as we may see later:
@smalltalkExample{'hello world' shuffled
@result{} 'wod llreohl'}
Note that results of each shuffle are different.

@cindex string, @method{sorted}

Similarly, we can ask a string to sort its characters:
@smalltalkExample{'hello world' sort
@result{}  ' dehllloorw'  }

@node Messages to number entities
@section Messages to number entities
@cindex number, root
@cindex number, @method{sqrt}
@cindex number, @method{squared}

Earlier, we discussed how @cuis{} knows about rational fractions.  The
four arithmetic operations and mathematical functions are implemented
with the binary messages understood by the rational numbers:
@smalltalkExample {(15 / 14) * (21 / 5) @result{} 9 / 2
(15 / 14) / ( 5 / 21) @result{} 9 /2 
(3 / 4) squared @result{} 9 / 16
(25 / 4) sqrt @result{} 5 / 2}

@exercise{Sum of the squares,squaredSum, @emph{Write the code to compute the
sum of the squares of the inverse of the first four integers.}}

@cindex number, decimal division
If @cuis{} integer division returns a rational number, how do we find the
result in decimal? One option is to write a number as a floating point literal,
a @dfn{Float}.
This kind of literal is written as the integer
part and fractional parts are separated by a dot ``.'':
@smalltalkExample{ 15.0 / 4 @result{} 3.75
15 / 4.0 @result{} 3.75}

Another option is to convert an integer to a float with the
@msg{asFloat} message. It is very useful when the integer is in a
variable:

@smalltalkExample{15 asFloat / 4
@result{} 3.75}

@cindex number, integer division
You can also ask for division with truncation to
get an integer result using 
the message @msg{//}:
@smalltalkExample{15 // 4
@result{} 3}

@cindex number, division reminder
The modulo reminder of the Euclidean division is computed with the message
@msg{\\\\}:
@smalltalkExample{15 \\\\ 4
@result{} 3}

@cindex number, @method{odd}
@cindex number, @method{even}
@cindex number, @method{isPrime}
@cindex number, @method{isDivisibleBy:}
@cuis{} knows some arithmetic operations to test if an integer is an
odd, even, prime number or divider. You just send the appropriate
unary or keyword message to the number:

@smalltalkExampleCaption{Testing on integer,integerBasicTest,
25 odd @result{} true
25 even @result{} false
25 isPrime @result{} false
23 isPrime @result{} true
91 isDivisibleBy: 7 @result{} true
117 isDivisibleBy: 7 @result{} false
117 isDivisibleBy: 9 @result{} true}

@cindex number, @method{gcd:}
@cindex number, @method{lcm:}
With specific @dfn{keyword messages} you compute the Least Common
Multiple and Greatest Common Divisor. A keyword message is composed of
one or several colon(s) ``:'' to insert argument(s):

@smalltalkExample{12 lcm: 15 @result{} 60
12 gcd: 15 @result{} 3}


@cindex tools, system browser
@cindex browser
@node A brief introduction to the system Browser
@section A brief introduction to the system Browser
Smalltalk organizes instance behaviors using classes.  
A class is an object which holds the methods which react to
the messages which are their names.

The @dfn{System Browser}, in short the @dfn{Browser}, is a tool to
rule all the classes in @cuis{}. It is both a tool to explore the
classes (system or user ones) and to write new classes and methods.

To access the tool, ...@clicksequence{Background click @click{}
@label{Open...} @click{} @label{Browser}}...

@figure{The System Browser,ch02-browserDetailed,12}

@cindex browser, class category
At the top left are the @dfn{class categories}, there are group of
classes part of the same theme. A caregory can also be used to
create a @dfn{Package}, which is
an organisational element to save code in a file system.
In @ref{ch02-browserDetailed}, the
selected class category is @label{Kernel-Numbers}, a group of
classes we already started using. The term @label{Kernel-} indicates it
is part of fundamental categories, but it is only a convention. See
the other categories as @label{Kernel-Text} and
@label{Kernel-Chronology} related to text and date entities.

@cindex class, declaration
Next to the right are the classes in the selected class category. They
are nicely presented in a parent-child class hierarchy. When a class is
first selected in this pane, its declaration appears in the large pane
bellow, the @class{Number} class declaration is:

@smalltalkExample{Magnitude subclass: #Number
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Kernel-Numbers'}

Observe a few important points in this declaration:

@itemize

   @item @class{Number} is a subclass of @class{Magnitude}. This means
   @class{Number} is a kind of specialized @class{Magnitude}.

   @item the declaration itself is Smalltalk code, indeed the message
   @msg{subclass:instanceVariableNames:classVariableNames:poolDictionaries:
   category:} was sent to @class{Magnitude} to create this class.

   @item the @smalltalk{subclass:} argument @class{Number} is prefixed
   with ``#'', it is a symbol, a kind of unique string. Indeed when
   declaring the @class{Number} class, the system does not know about it
   yet, so it is named as a symbol.

   @item The @smalltalk{instanceVariableNames:} argument is a string:
   the instance variables of the class are declared by name separated
   by a space. There is none in this class definition.

@end itemize

A subclass inherits behaviors from its parent superclass, and so only needs
to describe what is different from its superclass.  An instance
of @class{Number} adds methods (which define behaviors) unknown to an instance
of @class{Magnitude}.  We will explore this in detail as we go forward.

@cindex class, comment
To learn about the intend of a class, it is good practice to @strong{always}
visit the class comment. Often a comment comes also with code
examples to learn how to use the object; these code snippets can be
selected and executed in place as done from a Workspace. In
@ref{ch02-browserDetailed}, see the @label{comment} button to read or
to edit the comment of the selected class.

To the right of the class panel is the method categories panel.
A class may have with tens of methods, so grouping
them by category helps other users orient to find related methods.
As a reference, @class{Number}
has more than 100 instance side methods implemented in
itself@footnote{When considering its parents, the combined method count is
more than 300.}. Clicking the @label{arithmetic} category
directly gives access to related methods in the next and last pane at
the right.

@exercise{Count of methods,stringArith,@emph{How many methods is there
in the @label{arithmetic} method category of the @class{String}
class?}}


@cindex class, instance method
In the Browser, once a method is selected -- in
@ref{ch02-browserDetailed}, @method{abs} method -- the bottom part
shows its source code, ready to be explored or edited. Again, often,
you will read a small comment just after the method name, it is
surrounded by double quotes.

Every entity knows its class and answers it to the message @smalltalk{#class}.

@cindex browser, invoke from Workspace
A usefule tip: in the workspace @kbd{Ctrl-b} (@emph{@b{B}rowse})
on the class name will open a Browser on the named class:

@itemize

   @item In the Workspace, type @smalltalk{1 class} and print
   with @kbd{Ctrl-p},

   @item @class{SmallInteger} is printed and automatically highlighted as the current selection,

   @item Invoke the Browser on the selected @class{SmalltalkInteger}
   class with @kbd{Ctrl-b},

   @item A new Browser instance opens on the @class{SmalltalkInteger}, ready to
   be explored.

@end itemize

@node Spacewar! models
@section Spacewar! models
In last chapter we listed the protagonists of the game. Now, we
propose a first implementation of the game model with a set of classes
representing the involved entities:

@enumerate
 @item a central star @result{} @class{CentralStar} class,

 @item a star field @result{} @class{StarField} class,

 @item two space ships @result{} @class{SpaceShip} class,

 @item torpedoes @result{} @class{Torpedo} class.

@end enumerate

@cindex browser, class category (new)
Before defining these classes in @cuis{}, we want to create a
dedicated class category to group them there.

In a Smalltalk window, right-click on a pane will typically bring up a menu
of operations you can apply which are specific to that pane.
With the mouse pointer
over the class category pane of the Browser -- the most left one --
just do:

...@clicksequence{right mouse click @click{} @label{add item}}... then
key in @emph{Spacewar!}.


@cindex class, create (new)
Once our new category is set, the Browser proposes on the method
source code pane -- the bottom one -- a code template to create a new
class in the @label{Spacewar!} category:

@smalltalkExample{Object subclass: #NameOfSubclass
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'}

We replace the symbol @smalltalk{#NameOfSubclass} with a symbol
representing the name of the class we want to create. Let's start with
@smalltalk{#CentralStar}. To save the class, over the class
declaration code do ...@clicksequence{right mouse click @click{}
@label{Accept}}... @cuis{} will ask your initial and name
once. Alternatively, you can just do @kbd{Ctrl-s} (@emph{@b{S}ave}).

Then you repeat the process for each of @smalltalk{#StarField},
@smalltalk{#SpaceShip} and @smalltalk{#Torpedo}. If necessary, to get
another code template, click the class category @label{Spaceship!}.

When done, your class category should be filled with four classes as in
@ref{ch02-spacewarClassCategory}.

@figure{Spacewar! class category,ch02-spacewarClassCategory,5}

@cindex package, create (new)
@cindex package, save
Another important use case of a class category is to define a package
to save code on file.  A package saves the code of the classes held in
a given class category and a bit more, but more on that last point
later. To create our @label{Spacewar!} package and save our game code:

@enumerate
  @item Do ...@clicksequence{background click @click{}
  @label{Open...} @click{} @label{Installed Packages}}...

  @item On the new window, do ...@clicksequence{click @label{new}
  button @click{} Input @emph{Spacewar!} @click{} @key{Return}}...

  @item Do ...@clicksequence{select @label{Spacewar!} package @click{}
  @label{save} button}...

@end enumerate

@figure{Installed Package window,ch02-InstalledPackages,8}


@cindex package, load
A file @file{Spacewar!.pck.st} is created along the @cuis{} image
file.  Every time a package needs to be loaded in a fresh @cuis{}
environment, use the File List tool:

@enumerate

  @item Do ...@clicksequence{background click @click{}
  @label{Open...} @click{} @label{File List}}...

  @item Search for the file @file{Spacewar!.pck.st} and click the
  @label{install package} button  

@end enumerate

Now, we have created and saved the package. Whenever you start with a
fresh @cuis{} environment, you can load the game package.

The classes we defined are empty shells with no state nor
behavior. They will be complemented and refactored in the next
chapters.

