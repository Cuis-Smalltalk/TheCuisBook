@node Visual With Morph
@chapter Visual With Morph

Every object you see in @cuis{} is a @class{Morph} or is composed
of @class{Morph}s.  Basically, a @class{Morph} is an object with
state and behavior that can also depict itself on a computer
display screen.

Because Morphs are useful, when you look at
class @class{Morph} in a Hierarchy Browser you will
see a large number of methods and many, many subclasses.
But the basic ideas are quite simple.


@menu
* Ellipse Morph::
* Submorph::
* A brief introduction to Inspectors::
* Building your specialized Morph::
* Spacewar!'s Morphs::
@end menu

@node Ellipse Morph
@section Ellipse Morph
@cindex morph, ellipse
Let's start with one of the basic morphs, an @class{EllipseMorph}.
You could write @smalltalk{EllipseMorph new openInWorld} and @emph{@b{D}o-it}, but
we are doing visual things for now, so let's get a World Menu and select
from @strong{New Morph...} @strong{Basic} submenu and drag onto the desktop.

Every time one obtains a morph from a @strong{New Morph...} submenu, one gets
a different morph but made to a standard style.

@figure{Select @class{EllipseMorph} from a Menu,ch06-01-EllipseMorphFromMenu,8}

The basic challenge of @dfn{user interface design} is to communicate visibility and
control.  Where am I?  What can I do here?

One of the balance points in design is how to eliminate clutter.  One useful 
strategy is to reveal capabilities in context as they are needed.

@cindex morph, halo
In the case of Cuis, you have to know some basics because helpful tools are
there but stay out of the way.  At any time you can @kbd{Right-Click} on the desktop
to get the World Menu.  You can also @kbd{Middle-Click} on any @class{Morph} to get
a @dfn{halo} of @dfn{construction handles}, which show up as small colored circular
icons.  If you pause the cursor over one of these, you get a @dfn{tool tip}, a
temporary text popup who's name should give a clue to its usage.

If you click elsewhere the construction handles leave, but you can get them back
at any time with a mouse click.

@figure{Drag Construction Handle to Change Size,ch06-03-DragToEnlarge,4}

Now that you know this, move the yellow lower right handle with tool tip @strong{Change size}
via @dfn{Click-Drag}.  Just hold down the left mouse button while the cursor
is over the handle, move the cursor to the right and down, and release the mouse button.

@figure{A Larger Ellipse,ch06-04-Enlarged,4}

@node Submorph
@section Submorph
@cindex morph, submorph
@cindex morph, rectangle
Morphs can contain other morphs.  These interior morphs are called
@dfn{submorph}s of their containing morph. Again, you can do this by
writing the software ``code'', but let's do it directly with a
@class{RectangleLikeMorph}.

@page
First we obtain a RectangleLikeMorph from the @strong{New morph...} submenus.

@figure{Obtain a RectangleLikeMorph,ch06-05-AddRectangle,5}

Now drag the rect over the ellipse and @kbd{Middle-Click} on the rect and click on
the blue construction handle to gets the rect's @dfn{Morph Menu}.
Use the menu selection @strong{embed into...} and select the ellipse as
its new parent.

@figure{Make the Rect a Submorph of the Ellipse,ch06-06-EmbedRectIntoEllipse,5}

Now when you click-drag the ellipse, or use the @strong{Pick up} or @strong{Move}
construction handles, the rect is just a decoration for the ellipse.

Indeed, the rect seems to have fused into the ellipse.  Using the mouse where the
rect shows itself is just using the mouse on the ellipse.  This rect does not have many
interesting behaviors.

Let's add a behavior to just this one @class{RectangleLikeMorph}.

@node A brief introduction to Inspectors
@section A brief introduction to Inspectors
To get the construction halo for an interior morph, just
@kbd{Middle-Click} multiple times to ``drill down'' through the
submorph hierarchy.

@figure{Middle-Click for Construction Handles,ch06-07-MiddleClickRect,4.5}

@figure{Middle-Click again to descend into Submorphs,ch06-08-2ndMidClckToSubmorph,4.5}

There is an orange handle on the right, just under the green @strong{Duplicate} handle.
@kbd{Left-Click} this to get the @strong{Debug} menu.
Use this menu to get an @dfn{Inspector} for the rectangle.

@cindex tools, inspector
Observe @ref{ch06-11aColorClickOnRect}, on the left we have a pane for
self, all inst vars, and the individual instance variables.  Clicking
to select ``all inst vars'' and the values pane on the right shows
that the owner of the rect is the ellipse and rect currently has no
submorphs.

The lower pane is a Smalltalk code editor, basically a workspace,
where @strong{self} is bound to the object we are inspecting.

Inspectors work for every object by the way, not just morphs.

@figure{Add Instance Specific Behavior,ch06-11aColorClickOnRect,8}

To add a behavior to all instances of a class, we create an instance method.  Here we are going
to create a behavior for ``just this one RectangleLikeMorph instance''.

@cindex morph, properties
In addition to instance variables, a morph can have any number of
named @dfn{properties} which can be different for each morph.

We add two properties here:

@smalltalkExample{self setProperty: #handlesMouseDown: toValue: true.
self setProperty: #mouseButton1UpLocalPosition:
     toValue: [:ignoredEvent :ignoredPosition| self color: Color random]
}

These properties are special to the user interface.
You can find methods with these names in the @class{Morph} class to see what they do.

After selecting the text and @emph{@b{D}o-it}, each time you @kbd{Left-Click} on the rect it changes color!

Note that you can no longer move the ellipse by mouse-down on the rect,
because the rect now takes the mouse event.  You have to mouse-down on the Ellipse.  More on this below.

@cindex morph, move/pick up
One quick note on @strong{Move} versus @strong{Pick up}.  @strong{Move} moves a submorph
``within'' its parent.  @strong{Pick up} grabs a morph ``out'' of its parent. 

@figure{Move Submorph within its Parent,ch06-09-Move-Within,4}

@figure{Pick a Submorph out of its Parent,ch06-10-PickUp-2-MoveOut,4}

@page
Before we go on, let's use an inspector on the ellipse to change
values of a couple of its instance variables.

@figure{Inspect instance variables of the Ellipse,ch06-12-InspectEllipse,7}

Observe @ref{ch06-14-SetBorderColor}. In the lower pane of the
inspector, code can be executed in the context of the inspected
object. @smalltalk{self} refers to the instance. Here the pane
contains code to set the borderWidth and the borderColor.

@figure{Use Inspector to set borderColor and borderWidth,ch06-14-SetBorderColor,7}

In the typical case one wants to refine or change behaviors for all instances of a class.

@node Building your specialized Morph
@section Building your specialized Morph
@cindex morph, subclass
Let's make a simple subclass which changes color when @kbd{Left-Click}ed.
Create a new class just as we did with Spacewar! but subclass EllipseMorph with #ColorClickEllipse.

@smalltalkExample{EllipseMorph subclass: #ColorClickEllipse
             instanceVariableNames: ''
             classVariableNames: ''
             poolDictionaries: ''
             category: 'Spacewar!!'}

@kbd{Right-Click} on the @strong{Message Category} pane and select @strong{new category...}.
This brings up a number of selections and allows us to create new ones.
Select ``event handling testing''.  Then add the method @smalltalk{ColorClickEllipse>>handlesMouseDown:}.

@smalltalkExample{handlesMouseDown: aMouseButtonEvent
  "Answer that I do handle mouseDown events''
  ^true
}

Likewise, add a new catagory ``event handing'' and add the other method we need.

@smalltalkExample{mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
   "I ignore the mouseEvent information and change my color."
   self color: Color random}

Now, you have created a new Morph class and can select a ColorClickEllipse
from the World Menu @strong{New Morph..} and try it out.
These are fun to @kbd{Left-Click} on.  Make as many as you want!

@figure{Obtain ColorClickEllipse,ch06-15-ColorClickEllipse,8}

Now you know how to specialize an individual morph, or make a whole new class of them!


@node Spacewar! graphics
@section Spacewar! graphics

@subsection All Morphs
Previously we defined the actors of the game as subclasses of the very
general @class{Object} class (See
@ref{torpedoClassVariables}). However the game play, the central star,
the ships and the torpedoes are visual objects, each with a dedicated
graphic shape:

@itemize

  @item the game play is a simple rectangular area filled with the
  black color,

  @item the central star is a fluctuating yellow disk with an orange
  aura,

  @item the ships are rotating quadrangles each one painted with a
  different color,

  @item a torpedo is a rotating triangle we can decide to paint with
  a different color depending on the firing ship.
  
@end itemize

Therefore it makes sense to turn these actors as kind of
@class{Morph}s, the visual entity of @cuis{}. To do so, point a System
Browser to the class definition of each actor, replace the parent
class @class{Object} by @class{Morph}, then save the class definition
with @kbd{Ctrl-s}.

For example, the torpedo class as seen in @ref{torpedoClassVariables}
is edited as:

@smalltalkExample{Morph subclass: #Torpedo
   instanceVariableNames: 'position velocity lifeSpan'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'}

Moreover, as you may have guessed, a Morph already knows about its
position on screen -- it can be moved around in the screen with the
mouse cursor. Therefore the @smalltalk{position} instance variable is
redundant and should be removed. For now we keep it, it will be
removed later when we will know how to replace each of its use case
with its appropriate Morph counter part.

@exercise{Make all Morph, allActorsMorph, @emph{Edit
@smalltalk{SpaceWar}@comma{} @class{CentralStar} and @class{SpaceShip}
as subclasses of the @class{Morph} class.}}

As explained in the previous sections of this chapter, a morph can be
embedded in another game. In Spacewar!, a @class{SpaceWar} morph
instance representing the game play is the @emph{owner} of the central
star, space ship and torpedo morphs. Put in other words, the central
star, space ships and torpedoes are @emph{sub morphs} of a
@class{SpaceWar} morph instance.

The @method{SpaceWar>>initializeActors} in @ref{initActors} is not
complete without adding and positioning the central star and space
ships as sub morphs of the Spacewar! game play:

@smalltalkExampleCaption{Complete code to initialize the Spacewar! actors, initFullActors,
SpaceWar>>initializeActors
   centralStar @assign{} CentralStar new.
   self addMorph: centralStar.
   centralStar morphPosition: 0 @@ 0.
   ships @assign{} Array 
      with: (SpaceShip new color: Color white)
      with: (SpaceShip new color: Color red).
   self addAllMorphs: ships.
   ships first morphPosition: 200 @@ -200.
   ships second morphPosition: -200 @@ 200.
   torpedoes @assign OrderedCollection new}

There are two important messages: @msg{addMorph:} and
@msg{morphPosition:}. The former asks to the receiver morph to embed
its morph argument as a sub morph, the later asks to set the receiver
coordinates in its owner reference frame. From reading the code, you
can deduce the origin of the owner reference frame is its middle,
indeed our central star is in the middle of the game play.

There is a third message not written here, @msg{morphPosition}, to ask
the coordinates of the receiver in its owner reference frame.

Remember our discussion about the @smalltalk{position} instance
variable. Now you clearly understand it is redundant and we can remove
it from the @class{SpaceShip} and @class{Torpedo} definitions. Each
time we need to access the position, we just write @smalltalk{self
morphPosition} and each time we need to modify the position we write
@smalltalk{self morphPosition: newPosition}. More on that later.


@c refactor ship and torpedo as mobile entity
@cindex refactoring
@subsection The art of refactoring
In our @ref{newtonModel,, newtonian model} we explained the
space ships are subjected to the engine acceleration and the gravity
pull of the central star. The equations are described in
@ref{motionEquations}.

Based on these mathematics, we wrote the @smalltalk{SpaceShip>>update:}
method to update the ship position according to the elapsed time --
see @ref{spaceShipMechanic}.

So far in our model, a torpedo is not subjected to the central start
gravity pull nor its engine acceleration. It is supposing its mass is
zero which is unlikely. Of course the @smalltalk{Torpedo>>update:}
method is simpler than the space ship counter part -- see
@ref{torpedoMechanic}. Nevertheless, it is more accurate and even more
fun that the torpedoes are subjected to the gravity pull@footnote{So a
torpedo should come with a mass.} and its engine acceleration; an
agile space ship pilot could use gravity assist to accelerate a
torpedo fired close to the central star.

What are the impacts of these considerations on the torpedo and space
ship entities?

Firstly, they will share @emph{common states} as the mass, the
position, the velocity and the acceleration.

Secondly, they will share @emph{common behaviors} as the computation
to update the position and velocity.

Thirdly, they will have @emph{different states}: a torpedo has a life
span state while a space ship has fuel tank capacity and torpedoes
stock states.

Fourthly, they will have @emph{different behaviors}: a torpedo is self
destroyed when its life span expires, a space ship fires torpedoes and
accelerates as long as its fuel tank and its torpedoes count are not
zero.

Sharing states and behaviors along different states and behaviors are
a strong indication that the @class{SpaceShip} and @class{Torpedo}
classes should share a common ancestor more specialized than the
@class{Morph} class.

Doing such analysis on the computer model of the game is part of the
@dfn{refactoring} effort to avoid behavior and state duplication while
making more obvious common logic in the entities. The general idea of
code refactoring is to rework existing code to make it more elegant,
understandable and logic.

To do so, we want to introduce a @class{Mobile} class, kind of
 @class{Morph} with behaviors specific to a mobile subjected to
 accelerations. Its states are the mass, position, velocity and
 acceleration. Well, as we are discussing refactoring, the mass state
 does not really makes sense in our game, indeed our mobile's mass is
 constant. So we just need a method returning a literal number and we
 remove the @smalltalk{mobile} instance variable.

It results in this @class{Mobile} definition:

@smalltalkExampleCaption{Mobile in the game play,mobileClass,Morph subclass: #Mobile
   instanceVariableNames: 'velocity acceleration'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Spacewar!'}

@exercise{Refactoring @class{SpaceShip} and @class{Torpedo},refactoryShipTorpedo,
@emph{What should be the refactored definitions of the
@class{SpaceShip} and @class{Torpedo} classes?}}

The first behaviors we add to our @class{Mobile} are its initialization and
its mass:

@smalltalkExample{Mobile>>initialize
  super initialize.
  velocity @assign{} 0 @ 0.
  acceleration @assign{} 0
        
Mobile>>mass
  ^ 1}

The next method we want to add is the gravity acceleration calculus:

@smalltalkExampleCaption{Calculate the gravity force,gravityForce,
Mobile>>gravity
"Compute the gravity acceleration vector"
   | position |
   position @assign{} self morphPosition.
   @return{} -10 * self mass * owner starMass / (position r raisedTo: 3) * position}

A few comments:
@itemize

  @item @smalltalk{self morphPosition} returns a @class{Point}
  instance, the position of the mobile in the owner reference frame,

  @item @smalltalk{owner} is the @class{SpaceWar} instance
  representing the game play. It is the owner -- parent morph -- of
  the mobile. When asking @msg{starMass}, it interrogates its central
  star mass and return its value:

  @smalltalkExample{SpaceWar>>starMass
   @return{} centralStar mass}

  @item In @smalltalk{position r}, the @msg{r} message asks the radius
  attribute of a point considered in polar coordinates. It is just its
  length, norm. It is the distance between the mobile and the
  central star.

  @item @smalltalk{* position} really means multiply the previous
  scalar value with a point. Thus the returned value is a point, a
  vector in this context of gravity vector.

@end itemize



@c refactoring central star, no need for mass only a behavior
