@node Smalltalk Philosophy
@chapter Smalltalk Philosophy

@menu
* Context::
* Installing and configuring @cuis{}::
* Writing your first scripts::
@end menu

@node Context
@section Context

Before getting into the details of how to use the @cuis{} language and tools to build software, we need to understand the point of view, assumptions and intentions that shape how @cuis{} is meant to be used. We can call this the Smalltalk philosophy of programming.

These ideas are not new, but they are not the basis of mainstream approaches to software development. The first clear vision of an automated information processor that would help people think and share knowledge in greately improved ways was the Memex described by Vannevar Bush in "As We May Think", published in 1945 @footnote{@url{https://en.wikipedia.org/wiki/As_We_May_Think}}. This ideas inspired many later thinkers and inventors. The most straightforward development of this was the adoption of digital computers and networks as the support for Memex like systems. Notable milestones in this line of development were Ivan Sutherland's Sketchpad (1963), the RAND Tablet (1964), and Doug Engelbart's NLS ("oN-Line System") (1968). Later developments include Ted Nelson's Xanadu, the Apple Macintosh, the World Wide Web, and Smartphones and Tablet computers.

But, originally inspired by the Memex and the first wave of developments listed above, another completely different vision was developed. This vision was also influenced by the work understanding how humans learn of J. Piaget, J. Brunner, O. K. Moore and S. Papert. Alan Kay conceived the idea that computer software and computer programming could be a new medium for expressing thoughts and knowledge. He called his concept the "Dynabook" and described it in "Personal Dynamic Media" (1977). Another essential reading by Alan is "The Early History of Smalltalk".

Note the contrast with the mainstream point of view of programming, that is giving a computer a set of instructions so it can solve some problem. In this more common point of view, the only value of software is to solve a problem, and it is only as interesting as solving that problem.

The Dynabook vision included two main parts: hardware and software. Their original development took place at the Xerox PARC research center, in the 1970's. The first "interim Dynabook" hardware was the Xerox Alto, usually considered the first Personal Computer. The software part was Smalltalk. The design of both was guided by the objectives of making "Personal Dynamic Media" and the Dynabook real. The final version of Smalltalk built at Xerox was Smalltalk-80.

Hardware has evolved a lot in the following decades. Smartphones, Tablets and Laptops have effectively reached the kind of capabilities a Dynabook was envisioned to have. However, the same hasn't happened for software. After Smalltalk-80, further development of Smalltalk only meant making it an appropriate tool for professional software developers to write software for end users. Little has been advanced in the idea of a new medium for people to express ideas.

The development of the World Wide Web, and modern applications for handhelds and laptops, meant that software is written by professional developers: the kinds of media that are made available for users to create content include text, photographs and video, but not a more advanced way to express knowledge.

For this reason, Cuis is a Smalltalk system, and one that is rather close to Smalltalk-80. It is well adapted to modern hardware and operating environments, and includes many modern programming facilities.

But we still believe that the best way to write programs is to capture a set of ideas and knowledge, that other people can understand, and that a computer can run. @cuis{} is meant to be used this way.


@node Installing and configuring @cuis{}
@section Installing and configuring @cuis{}
@cuis{} is an environment and a programming language executed on a
virtual computer. It is based on two major components:
the Smalltalk @dfn{virtual machine} conceptualizing this virtual
computer and an @dfn{image} representing the state of this computer.

The virtual machine is an executable program running on a dedicated
host (GNU/Linux, Mac OS X, Windows, etc.). It is called the @dfn{Open
Smalltalk Virtual Machine}, or Squeak @vm{} in short. There are
different flavors of @vm{}, one for each combination of Operating
System and CPU architecture. Therefore, one @vm{} compiled
for Windows in Intel architecture will not work on Linux in
ARM architecture. You need the specific @vm{} compiled for
the combination of Operating System and CPU architecture
your computer is based on.

The image is a regular file feeding the @vm{} with all the objects
 defining the state of the virtual computer. These objects are
 classes, methods, instances of those classes as numbers, strings,
 windows, debuggers whatever existed when the state of the virtual
 computer was saved. An image file saved on a given Operating System
 and CPU architecture run identically on another system as
 long as the same @vm{} version is used.

What makes @cuis{} special is the living entities in the image: its
classes population and arrangement, how they inherit from each
other. The @cuis{} moto is to be a tiny, coherent and human
understandable Smalltalk environment; its class count is typically
less than 600.

To get you started easily, we provide three
archives@footnote{@url{http://github.com/Cuis-Smalltalk/BookResources}}
for GNU/Linux, Mac OS X and Windows on Intel architecture. These
archives come with the dedicated @vm{} and the image of @cuis{}
@value{cuisVersion}. Into this image we pre-installed a few packages
to make your life easier when you experience the examples and
exercises of the book. At the reading time of this book, @cuis{} has
likely evolved with a more recent version, nevertheless your learning
is transferable to more recent version of @cuis{}.

To get @cuis{} running on your computer, follow the instructions in
the @file{README} file accompanying the archive. Once you get @cuis{}
running, read the information displayed on the windows. When you are
done, close these windows, next you will adjust @cuis{} to your
preferences.

@subsection Editing your preferences
Once you read the instructions on the default windows, the second
things you want to do is to adjust its visual properties to fit your
preferences and needs. To do so, access the World menu
...@clicksequence{Background click @click{} Preferences...} then
select the pin on the top right of the menu to make it permanent. Here
you have the most important options: the choice for the @strong{font
size}, the @strong{themes} whenever your prefer light or dark
colouring. There are other preferences you can explore by
yourself. Once you are done, access again the World menu
...@clicksequence{Background click @click{} Save}... to make your
preferences permanent. In this book, we keep the default @cuis{}
theme, we suggest you to do the same so your environment reflects the
book screenshots.

@figure{Set Preferences,ch01-Preferences,12}

@subsection Fun with window placement
@cindex tools, workspace
The first tool to discover is the @dfn{Workspace} tool. It is a kind
of text editor to key in Smalltalk code you can execute
immediately. Do a ...@clicksequence{Background click @click{}
Open... @click{} Workspace}...

Now we ask @cuis{} to make the windows placement: click the blue icon
(top left) to access the window option and experiment with the white
area to place the Workspace window at the half left of the @cuis{}
environment.

@figure{Window options,ch01-img1a,7}

The @option{resize...} option even offers more freedom to place the
window. Resolve the following exercise:

@exercise{Middle placement,exePlacement, @emph{Use the
@option{resize...} option to place the Workspace centered on @cuis{}
environment.}}

@node Writing your first scripts
@section Writing your first scripts
In this section we present a few scripts so you will get a taste and
feeling about Smalltalk code. The examples are associated with small
exercises to experiment with and accompanied with solutions in the
annex. We intentionally keep the details of the syntax out of this
section.

Smalltalk script are usually written in a Workspace. The usual
@emph{Hello world!} program is written as:

@smalltalkExampleCaption{The traditional 'Hello World!' program,hello,
Transcript show: 'Hello World'}

@cindex tools, transcript
To execute this code, select it with the mouse and
...@clicksequence{right mouse click @click{} Do it (d)}...  Nothing
happen! Indeed to see the output, you need a @dfn{Transcript} window,
it is a place where programmer send information for the user as we are
doing in our example. Do ...@clicksequence{Background click @click{}
Open... @click{} Transcript}... and execute again the code.

@figure{Transcript window with output,ch01-img2,3}

This code comes in three parts:

@itemize

@item the literal @smalltalk{'Hello World!'}  

@item the message @msg{show:} with its argument @smalltalk{'Hello World!'}

@item the class @class{Transcript} receiving the message @msg{show:} with its argument

@end itemize

The action of printing takes place in the class
@class{Transcript}. The code execution is invoked with keyboard
shortcuts @kbd{Ctrl-A} then @kbd{Ctrl-D} (@emph{@b{D}o it}).

@smalltalkExampleCaption{Multiple lines, hello2,
Transcript show: 'Hello World!'.
Transcript newLine.
Transcript show: 'I am Cuising'}

In this three lines script, observe how the line are separated by a
dot ``.''. It is really a line separator not needed in the third line
nor in a one line script. The message @msg{newLine} has no argument.

@cindex cascade of messages
In the @ref{hello2} example, the message @msg{show:} and @msg{newLine}
are sent to the same @class{Transcript} class. In such circumstance,
we can use the cascade technique to avoid this repetition. The
receiver @class{Transcript} is written once and the sent messages are
separated by semicolon:

@smalltalkExampleCaption{Cascade of message, helloCascade,
Transcript
   show: 'Hello World!';
   newLine;
   show: 'I am Cuising'}

Observe the text layout to ease code understanding. It is possible to
write the cascade of messages in one line, but it reduces the
readability of the code:

@smalltalkExample{Transcript show: 'Hello World!'; newLine; show: 'I am Cuising'}

The @class{Transcript} class is most of the time used to output useful
information when developing an application. As an alternative to the
@kbd{Ctrl-d} shortcut, @kbd{Ctrl-p} (@emph{@b{P}rint it}) executes the
script and prints in the Workspace the result of the last line of the
script.

@subsection Fun with numbers
@cindex number, integer

In your Workspace, to compute a factorial execute the example bellow
with @kbd{Ctrl-a} then @kbd{Ctrl-p}:
@smalltalkExample{100 factorial
@result{}  9332621544394415268169923885626670049071596826438162146859
29638952175999932299156089414639761565182862536979208272237582
51185210916864000000000000000000000000}

@cuis{} handles very large integer number without the need to use
special type or method. To convince yourelf try the example bellow:
@smalltalkExample{10000 factorial / 9999 factorial
@result{} 10000}

If you execute and print with @kbd{Ctrl-p} @smalltalk{10000
factorial}, you realize it takes far more time to print one factorial
than computing two factorials and a division. The result is an integer
as expected, not a decimal number answer as many computer languages
will return.

As we are discussing division, you may not get the result you think:
@smalltalkExample{15 / 4
@result{} 15/4}

It looks like @cuis{} is lazy because it does not respond the decimal
number @smalltalk{3.75} as we were expecting. In fact @cuis{} wants to
be as accurate as possible, and its answer is a rational fraction! After
all, fractions are just division we are too lazy -- because it
is troublesome -- to compute, @cuis{} does just that!

Try out this to understand what is happening underneath:
@smalltalkExample{(15 / 4) + (1 / 4)
@result{} 4}

Is it not wonderful? @cuis{} computes with rational numbers. We
started with division and addition operations on integer, and we got
an accurate result thanks to intermediate computation on rational
numbers.

@cuisNote{In the example, observe how the parenthesis are used
although in arithmetic calculation the division is operated first. With
@cuis{} you need to explicit the order of operation with
parenthesis. We will explain why in Part Two.}

@exercise{Inverse sum,inverseSum, @emph{Write the code to compute the
sum of the first four integer inverses.}}
@cindex number, root
@cindex number, @msg{sqrt}
@cindex number, @msg{squared}
All four arithmetic operations and mathematical functions are
compatible with the rational number representation:
@smalltalkExample {(15 / 14) * (21 / 5) @result{} 9 / 2
(15 / 14) / ( 5 / 21) @result{} 9 /2 
(3 / 4) squared @result{} 9 / 16
(25 / 4) sqrt @result{} 5 / 2}

@exercise{Sum of the squares,squaredSum,Write the code to compute the
sum of the squares of the inverse of the first four integers.}

@cindex number, decimal division
If @cuis{} divides integer as rational number, how to compute the
decimal division? One option is to write a number as a @dfn{Float}, it
is the decimal representation in programming language, the integer
part and fractional parts are separated by a dot ``.'':
@smalltalkExample{ 15.0 / 4 @result{}3.75
15 / 4.0 @result{} 3.75}

Another option is to convert an integer to a float with the
@msg{asFloat} message. It is very useful when the integer is in a
variable:

@smalltalkExample{15 asFloat / 4
@result{} 3.75}

@cindex number, integer division
Alternatively to the decimal division, you ask integer division with
the message @msg{//}:
@smalltalkExample{15 // 4
@result{} 3}

@cindex number, division reminder
The reminder of the Euclidean division is computed with the message
@msg{\\\\}:
@smalltalkExample{15 \\\\ 4
@result{} 3}


@cindex number, @msg{odd}
@cindex number, @msg{even}
@cindex number, @msg{isPrime}
@cindex number, @msg{isDivisibleBy:}
@cuis{} knows some arithmetic operations to test if an integer is an
odd, even or prime number. You just send the appropriate message to
the number:

@smalltalkExampleCaption{Testing on integer,integerBasicTest,
25 odd @result{} true
25 even @result{} false
25 isPrime @result{} false
23 isPrime @result{} true
91 isDivisibleBy: 7 @result{} true
117 isDivisibleBy: 7 @result{} false
117 isDivisibleBy: 9 @result{} true}

@cindex number, @msg{gcd:}
@cindex number, @msg{lcm:}
With specific @dfn{keyword messages} you compute the Least Common
Multiple and Greatest Common Divisor. A keyword message is composed of
one or several colon(s) ``:'' to insert argument(s):

@smalltalkExample{12 lcm: 15 @result{} 60
12 gcd: 15 @result{} 3}
Integer can be printed in different forms:

@cindex number, roman
@cindex number, as words
@cindex number, base
@smalltalkExample{2020 printStringRoman @result{} 'MMXX' 
2020 printStringWords  @result{} 'two thousand, twenty'
"Number as the Maya did"
2020 printStringBase: 20 @result{} '510'}

@subsection Fun with text
@cindex string
A @dfn{String} is the way text is represented in a programming
language, it is a collection of characters. We already met string with
our first script, it is enclosed in single quotes: @smalltalk{'hello
world!'}. We capitalize it with the @msg{capitalized} message:

@cindex string, capitalized
@smalltalkExample{'hello world!' capitalized
@result{} 'Hello world!' }

@exercise{Capitalize number as words,capWordNumber,@emph{Print 2020 as
words capitalized.}}

@cindex string, concatenate
Two strings are concatenated with the @msg{,} message
@smalltalkExample{'Hello', ' ', 'my beloved', ' ', 'friend'
@result{} 'Hello my beloved friend'}

@cindex string, character access
Access to a character in a string is done with the keyword message
@msg{at:} and its index position in the string:
@smalltalkExample{'Hello' at: 1 @result{} $H
'Hello' at: 5 @result{} $o}

Observe how a character is prefixed with the ``$'' symbol.

@strong{Caution.} The index position starts naturally from 1 to the
string length.

To change one character, use the companion two keywords message
@msg{at:put:}. The argument must be noted as a character:
@smalltalkExample{'Hello' at: 2 put: $a; yourself
@result{} 'Hallo'}

Observe the use of the cascade with the @msg{yourself} message. It is
sent to the instance string to get it returned.

@exercise{Hello to Belle,helloBelle, @emph{Replace each character of
the string 'Hello' to become 'Belle'}}

@cindex character, ascii
Character can be converted to integer and integer to character:
@smalltalkExample{$A asciiValue @result{} 65
(65 + 25) asCharacter @result{} $Z}

@cindex string, shuffled
@cindex collection, shuffled
Shuffling a string is funny but without much use. Nevertheless,
shuffling apply to any kind of collection, not only to string, and it
proves to be of some use as we may see later:
@smalltalkExample{'hello world' shuffled
@result{} 'wod llreohl'}

@cindex string, @msg{sorted}
We can write the same about sorting a string:
@smalltalkExample{'bonjour' sorted
@result{}#($b $j $n $o $o $r $u)}

