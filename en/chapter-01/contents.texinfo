@node Smalltalk Philosophy
@chapter Smalltalk Philosophy

Before getting into the details of how to use the @cuis{} language and
tools to build software, we need to understand the point of view,
assumptions and intentions that shape how @cuis{} is meant to be
used. We can call this the Smalltalk philosophy of programming.

@menu
* Historical Context::
* Installing and configuring @cuis{}::
* Writing your first scripts::
* Spacewar!::
@end menu

@node Historical Context
@section Historical Context

One major idea in software is that programming is merely giving a
computer a set of instructions to solve some problem.  In this point
of view, the only value of software is to achieve a result, and it is
only as interesting as solving that problem.  Furthermore, programming
is left to a professional guild whose technical knowledge is how to
write software.
@note{Can we simplify? Solve is repeated 3 times.}

Our focus is on one thread in the history of powerful ideas which give
a different lens through which to explore software development than
the @emph{just solve a problem} view. We think they are worth
revisiting. 

The first clear vision of an automated information processor to assist
people to think and to share knowledge in greatly improved ways was
called Memex and described in Vannevar Bush essay ``As We May Think'',
1945 @footnote{@url{https://en.wikipedia.org/wiki/As_We_May_Think}}.
His ideas inspired many later thinkers and inventors in the adoption
of digital computers, networks and hypertext as the substrate for
Memex-like systems.  @footnote{Notable milestones in this line of
development were Ivan Sutherland's Sketchpad (1963), the RAND tablet
(1964), and Doug Engelbart's NLS ("oN-Line System") (1968). Later
developments include Ted Nelson's Xanadu, the Apple Macintosh, the
World Wide Web, smartphones and tablet computers.}

Originally inspired by Memex, another vision was also developed with
insights in understanding how humans learn.  @footnote{Early notables
here are J. Piaget, J. Brunner, O. K. Moore, and S. Papert.}  Alan Kay
conceived the idea that computer software and computer programming
could become a new medium for expressing thoughts and knowledge. The
ability to express ideas in this new medium would be the new
literacy. Every person should learn to read and write in this new
medium, at least to the extent of their personal needs. He called his
concept the @dfn{Dynabook} and described it in ``Personal Dynamic
Media'', 1977
@footnote{@url{http://augmentingcognition.com/assets/Kay1977.pdf}}.
Other useful insights shared by Kay can be gleaned from his paper
``The Early History of Smalltalk''
@footnote{@url{http://worrydream.com/EarlyHistoryOfSmalltalk}}.

The dynamic book vision -- Dynabook -- included two main parts:
hardware and software. The original development took place at the
Xerox PARC research center, in the 1970's. The first @emph{interim
Dynabook} hardware was the Xerox Alto, usually considered the first
personal computer. The software part was Smalltalk. The design of both
was guided by the objectives of making @emph{Personal Dynamic Media}
and the Dynabook real. The final version of Smalltalk built at Xerox
was Smalltalk-80.

Given the relatively weak capabilities of computer hardware at this
time, implementing this vision presented real challenges, and much
creativity was called for.  Today, smartphones, tablets and laptops
have the hardware capabilities a Dynabook requires. However, the same
advance hasn't happened for personal software. After Smalltalk-80,
evolution was directed mostly toward making Smalltalk an appropriate
tool for professional developers to write software for end users. Only
a modest effort has been undertaken toward the idea of a new medium
for people to express ideas.

The development of the World Wide Web with modern applications for
handhelds and laptops, along with the disappearance of most @emph{end
user programming} tools, meant that software is almost exclusively
written by professional developers. The kinds of media that are made
available for users to create content include text, photographs and
video, but not a more advanced way to capture lessons learned, where
the user can @emph{see all the way to the bottom} of what is going on
and be able to develop their own tools as required.
@note{``capture lessons learned'' is too obscure. Elaborate}


We believe that everyone should have full access to the software that
runs our systems.  Understanding and exploring computer systems
requires writing software in ways that can be read and shared.

@c The pattern is not one of working in relative isolation on a single
@c task, for example to develop a piston assembly for an internal
@c combustion engine.  It is more like working together in a small,
@c mostly self sufficient village where people still know how to make
@c their own clothing and tools and everyone knows where to get shoes, a
@c nail, seeds, or a bag of salt.

The thinking change in problem solving can shift from @emph{What can I
do here with what I am presented?} to asking @emph{What tools do I
need to be successful here?}  and then building them to be ever more
successful.

Dan Ingalls, one of the early Smalltalk inventors, wrote in his
article ``Design Principles Behind Smalltalk'', 1981
@footnote{@url{http://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html}}
a set of principles that still guide us today. Among these:
@quotation
@strong{Personal Mastery.} If a system is to serve the creative
spirit, it must be entirely comprehensible to a single individual.

@strong{Reactive Principle.} Every component accessible to the user
should be able to present itself in a meaningful way for observation
and manipulation.

@author Dan Ingalls
@end quotation

This way of thinking about software systems is important to us.

For this reason, Cuis is a Smalltalk system which is still rather
close to Smalltalk-80. It is well adapted to modern hardware and
operating environments, and includes many modern programming
facilities.
@note{the latter statement is vague.}

We believe the best way to write programs is to capture a set of ideas
and knowledge other people can understand, and that a computer can
run. @cuis{} is meant to be used this way.
@note{it is very vague too.}


@node Installing and configuring @cuis{}
@section Installing and configuring @cuis{}
@cuis{} is an environment and a programming language executed on a
idealized virtual computer. It is based on two major components:
the Smalltalk @dfn{virtual machine} conceptualizing this virtual
computer and an @dfn{image} representing the state of this computer.

The virtual machine is an executable program running on a dedicated
host (GNU/Linux, Mac OS X, Windows, etc.). It is called the @dfn{Open
Smalltalk Virtual Machine}, or Squeak @vm{} in short. There are
different flavors of @vm{}, one for each combination of Operating
System and CPU architecture. Therefore, one @vm{} compiled
for Windows on Intel architecture will not work in Linux on
ARM architecture. You need the specific @vm{} compiled for
the combination of Operating System and CPU architecture
your computer is based on.

The image is a regular file feeding the @vm{} with all the objects
 defining the state of the virtual computer. These objects are
 classes, methods, instances of those classes as numbers, strings,
 windows, debuggers -- whatever existed when the state of the virtual
 computer was saved. An image file saved on a given Operating System
 and CPU architecture will run identically on another system as
 long as the same @vm{} version is used.

What makes @cuis{} special is the living entities in the image: its
class population and arrangement, how the classes inherit from each
other. The @cuis{} goal is to be a small, coherent Smalltalk
development environment that, with study, is
comprehensible to a single person;
its class count is typically less than 600.

To get you started easily, we provide three
archives@footnote{@url{http://github.com/Cuis-Smalltalk/BookResources}}
for GNU/Linux, Mac OS X and Windows on Intel architecture. These
archives come with the dedicated @vm{} and the image of @cuis{}
@value{cuisVersion}. Into this image we pre-installed a few packages
to make your life easier when you experience the examples and
exercises of the book. By the time you read this book, @cuis{} will
likely have evolved to have a newer version.  What you learn here
should, however, be easily transferable.

To get @cuis{} running on your computer, follow the instructions in
the @file{README} file accompanying the archive. Once you get @cuis{}
running, read the information displayed on the windows. When you are
done, close these windows, next you will adjust @cuis{} to your
preferences.

@subsection Editing your preferences
Once you read the instructions on the default windows, the next 
thing you want to do is to adjust its visual properties to fit your
preferences and needs. To do so, access the World menu
...@clicksequence{Background click @click{} @label{Preferences...}} then
select the pin on the top right of the menu to make it permanent. Here
you have the most important options: the choice for the @strong{font
size}, the @strong{themes} whenever your prefer light or dark
colouring. There are other preferences you can explore by
yourself. Once you are done, access again the World menu
...@clicksequence{Background click @click{} @label{Save}}... to make your
preferences permanent. In this book, we keep the default @cuis{}
theme, we suggest you to do the same so your environment reflects the
book screenshots.

@figure{Set Preferences,ch01-Preferences,12}

@subsection Fun with window placement
@cindex tools, workspace
The first tool to discover is the @dfn{Workspace} tool. It is a kind
of text editor to key in Smalltalk code you can execute
immediately. Do a ...@clicksequence{Background click @click{}
@label{Open...} @click{} @label{Workspace}}...

Now we ask @cuis{} to make the windows placement: click the blue icon
(top left) to access the window option and experiment with the white
area to place the Workspace window at the half left of the @cuis{}
environment.

@figure{Window options,ch01-img1a,7}

The @label{resize...} option even offers more freedom to place the
window. Resolve the following exercise:

@exercise{Middle placement,exePlacement, @emph{Use the
@label{resize...} option to place the Workspace centered on @cuis{}
environment.}}

@node Writing your first scripts
@section Writing your first scripts
In this section you will learn how to write simple scripts in the
Workspace to get a taste and feeling about Smalltalk code. The
examples are associated with small exercises to experiment with and
accompanied with solutions in the annex. We intentionally keep the
details of the syntax out of this section.

In a Workspace, the usual @emph{Hello world!} program can be written
in Smalltalk:

@smalltalkExampleCaption{The traditional 'Hello World!' program,hello,
Transcript show: 'Hello World'}

@cindex tools, transcript
To execute this code, select it with the mouse and
...@clicksequence{right mouse click @click{} @label{Do it (d)}}...
You may now see nothing happen! Indeed to see the output, you need a
@dfn{Transcript} window to be visible.  The @class{Transcript} is a
place where programmer can send information for the user as we are
doing here. Do ...@clicksequence{Background click @click{}
@label{Open...} @click{} @label{Transcript}}... and execute the code
again.

@figure{Transcript window with output,ch01-img2,3}

This code comes in three parts:

@itemize

@item the string literal @smalltalk{'Hello World!'}  

@item the message @msg{show:} with its argument @smalltalk{'Hello World!'}

@item the class @class{Transcript} receiving the message @msg{show:} with its argument

@end itemize

The action of printing takes place in the class
@class{Transcript}. The code execution is invoked with keyboard
shortcuts @kbd{Ctrl-A} (@emph{select @b{A}ll})
then @kbd{Ctrl-D} (@emph{@b{D}o it}).

@smalltalkExampleCaption{Multiple lines, hello2,
Transcript show: 'Hello World!'.
Transcript newLine.
Transcript show: 'I am Cuising'}

In this three line script, observe how the lines are separated by a
dot ``.''. This period is a line separator so it is not needed in the third line
nor in a one line script. The message @msg{newLine} has no argument.

@cindex string
A @dfn{String} is the way text is represented in a programming
language, it is a collection of characters. We already met string with
our first script, it is enclosed in single quotes: @smalltalk{'hello
world!'}. We capitalize it with the @msg{capitalized} message:

@cindex string, capitalized
@smalltalkExample{Transcript show: 'hello world!' capitalized
@result{} 'Hello world!' }

@cindex string, concatenate
Two strings are concatenated with the @msg{,} message:
@smalltalkExampleCaption{Concatenate strings, concatenateStrings,
Transcript show: 'Hello '@comma{} 'my beloved '@comma{} 'friend'
@result{} 'Hello my beloved friend'}

@exercise{Concatenate and capitalize, concatenateCapitalize,
@emph{Add a message to modify @ref{concatenateStrings} to output
'Hello MY BELOVED friends'}}

@subsection Fun with numbers
@cindex number, integer

In your Workspace, to compute a factorial execute the example bellow
with @kbd{Ctrl-a} then @kbd{Ctrl-p} (@emph{@b{P}rint it}):
@smalltalkExample{100 factorial
@result{}  9332621544394415268169923885626670049071596826438162146859
29638952175999932299156089414639761565182862536979208272237582
51185210916864000000000000000000000000}

@cuis{} handles very large integer number without the need to use
special type or method. To convince yourelf try the example bellow:
@smalltalkExample{10000 factorial / 9999 factorial
@result{} 10000}

If you execute and print with @kbd{Ctrl-p} the code: @smalltalk{10000
factorial}, you realize it takes far more time to print one factorial
than computing two factorials and a division. The result is an integer
as expected, not a decimal number answer as many computer languages
will return.

As we are discussing division, you may not get the result you think:
@smalltalkExample{15 / 4
@result{} 15/4}

It looks like @cuis{} is lazy because it does not respond the decimal
number @smalltalk{3.75} as we were expecting. In fact @cuis{} wants to
be as accurate as possible, and its answer is a rational fraction! After
all, fractions are just division we are too lazy -- because it
is troublesome -- to compute, @cuis{} does just that!

Try out this to understand what is happening underneath:
@smalltalkExample{(15 / 4) + (1 / 4)
@result{} 4}

Is it not wonderful? @cuis{} computes with rational numbers. We
started with division and addition operations on integer, and we got
an accurate result thanks to intermediate computation on rational
numbers.

@cuisNote{In the example, observe how the parenthesis are used
although in arithmetic calculation the division is operated first. With
@cuis{} you need to specify the order of operations with
parenthesis. We will explain why later.}

@exercise{Inverse sum,inverseSum, @emph{Write the code to compute the
sum of the first four integer inverses.}}

Integers can be printed in different forms with the appropriate
message:

@cindex number, roman
@cindex number, as words
@cindex number, base
@smalltalkExample{2020 printStringRoman @result{} 'MMXX' 
2020 printStringWords  @result{} 'two thousand, twenty'
"Number as the Maya did"
2020 printStringBase: 20 @result{} '510'}

@exercise{Capitalize number as words,capWordNumber,@emph{Print 2020 as
words capitalized.}}


@cindex number, literal
@cindex literal, number
Integer and float numbers we have played with are @dfn{Numeric
Literals}. Literals are building blocks of the language and considered as
constant expressions.  They literally are as the appear.
There are different syntax variants to write a number:

@multitable @columnfractions .45 .55
@headitem Numeric literal @tab What it represents
   @item @smalltalk{1}                          @tab decimal integer
   @item @smalltalk{2r101}                      @tab binary integer
   @item @smalltalk{16rFF}                      @tab hexadecimal integer
   @item @smalltalk{1.5}                        @tab floating point number
   @item @smalltalk{2.4e7}                      @tab exponential notation
@end multitable

Depending on the value we need to use, we mix these literal
representation:

@smalltalkExample{16rA + 1 + 5e-1 + 6e-2
@result{} 289/25}

@node Spacewar!
@section Spacewar!
The Spacewar! game was initially developed in 1962 by Steve Russell on
DEC PDP-1 minicomputer. It is said to be the first known video game
installed on several computers and it was very popular in the
programming community in the 1960s. It was ported and rewritten
several time to different hardware architectures and complemented with
additional features. @emph{Computer Space}, the first arcade video
game cabinet was a clone of Spacewar!

@figure{Spacewar! game on DEC PDP-1 minicomputer,ch01-SpacewarPDP,8}

Wikipedia describes very precisely this space combat simulation game:

@quotation
The gameplay of Spacewar! involves two monochrome spaceships called
"the needle" and "the wedge", each controlled by a player, attempting
to shoot one another while maneuvering on a two-dimensional plane in
the gravity well of a star, set against the backdrop of a
starfield. The ships fire torpedoes, which are not affected by
the gravitational pull of the star. The ships have a limited number of
torpedoes and supply of fuel, which is used when the player fires the
ship's thrusters. Torpedoes are fired one at a time by flipping a
toggle switch on the computer or pressing a button on the control pad,
and there is a cooldown period between launches. The ships remain in
motion even when the player is not accelerating, and rotating the
ships does not change the direction of their motion, though the ships
can rotate at a constant rate without inertia.

Each player controls one of the ships and must attempt to shoot down
the other ship while avoiding a collision with the star or the
opposing ship. Flying near the star can provide a gravity assist to
the player at the risk of misjudging the trajectory and falling into
the star. If a ship moves past one edge of the screen, it reappears on
the other side in a wraparound effect. A hyperspace feature, or "panic
button", can be used as a last-ditch means to evade enemy torpedoes by
moving the player's ship to another location on the screen after it
disappears for a few seconds, but the reentry from hyperspace occurs
at a random location, and in some versions there is an increasing
probability of the ship exploding with each use.
@author Wikipedia, @url{https://en.wikipedia.org/wiki/Spacewar!#Gameplay,Spacewar!,Spacewar!}
@end quotation

Therefore, the protagonists of the game are:

@enumerate
 @item a @strong{central star} generating a gravity field,

 @item a @strong{star field} background,

 @item two @strong{space ships} called @emph{the needle} and @emph{the
 wedge} controlled by two players.

 @item @strong{torpedoes} fired by the space ships.

@end enumerate

@figure{Spacewar! game play,ch01-SpacewarGameplay,8}


